\documentclass[a4paper,english,cleveref,autoref,thm-restate,anonymous,]{lipics-v2021}
\bibliographystyle{plainurl}

%% Thesis:
%%  the addition of sound nominal types to an optionally-typed codebase
%%  can effectively improve peformance

% > Here’s the thing: I think this is the sort of thing an academic might say “oh,
% > this is too much work, it’d never work” But in fact it looks like they seem to
% > be making it work -- Shriram 2021-09-30


%% TODO before submission
%% - look out for PROGRESSIVE TYPES~\cite{pqk-onward-2012}, where changing annotations
%%   helps the static checker find new errors. ChkDict is one example.

%% TODO after submission, before camera-ready
%% - 

\title{Gradual Soundness: Lessons from Static Python}
%% ... types make things fast?
%% ... gradual migratory progressive soundness

%\titlerunning{short title}

\author{Kuang-Chen Lu}{Department of Computer Science, Brown University, USA}{LuKuangchen1024@gmail.com}{}{}
\author{Ben Greenman}{Department of Computer Science, Brown University, USA}{benjamin.l.greenman@gmail.com}{0000-0001-7078-9287}{}
\author{Carl Meyer}{Facebook, Inc.}{carljm@fb.com}{}{}
\author{Dino Viehland}{Facebook, Inc.}{dinoviehland@fb.com}{}{}
\author{Shriram Krishnamurthi}{Department of Computer Science, Brown University, USA}{shriram@brown.edu}{0000-0001-5184-1975}{}

\authorrunning{K-C. Lu, B. Greenman, C. Meyer, D. Viehland, S. Krishnamurthi}
%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Kuang-Chen Lu, Ben Greenman, Carl Meyer, Dino Viehland, and Shriram Krishnamurthi}
%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{gradual typing, migratory typing}

\category{} %optional, e.g. invited paper

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{
  Thanks to
   Guido van Rossom for stimulating tweets.
  This work was partly supported by the US National Science Foundation.
  This research was also developed with funding from the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL).
  The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S.~Government.
  Greenman received support from NSF grant 2030859 to the CRA for the \href{https://cifellows2020.org}{CIFellows} project.
}

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\newcommand{\shorturl}[2]{\href{#1#2}{#2}}
\newcommand{\SP}{Static Python}
\newcommand{\code}[1]{\texttt{#1}}


\begin{abstract}
  Soundness, migratory typing.
  Novel run-time check strategy, combines concrete and transient for ergonomics.
\end{abstract}


\section{Typing for Performance}
\label{s:intro}

Gradual typing has attracted significant interest as a solution to
the impasse between static and dynamic typing.
The premise is simple: let programmers introduce types in part of a
codebase and while leaving the rest untyped.
Run-time checks can in principle enforce the assumptions that
typed code makes about untyped components, thereby ensuring that
the types are sound no matter how the untyped code behaves.

Unfortunately, the high run-time cost of sound types has split
the gradual typing community.
Industry teams have developed innovative type systems that accommodate
untyped designs, but these systems are all unsound [CITE].
These systems intentionally check nothing at run-time when untyped values enter
typed code.
Academic teams have primarily focused on the theory of sound
gradual types, formulating correctness properties and studying ever-more-descriptive types [CITE].
A few academics have studied the cost of run-time checks
in detail [CITE] and proposed implementation methods [CITE],
compiler technology [CITE],
and even weakened semantics [CITE], but none of these efforts
decisively close the performance gap.
The most promising attempt is the \emph{concrete} semantics
for gradual types [CITE kafka nom etc], but its low performance
overhead stems from severe restrictions on untyped code.
These restrictions may not be acceptable to the maintainers of a
working untyped codebase.
Indeed, the maintainers might prefer to re-implement their system
in a typed language, as Dropbox recently did with its core sync
engine.\footnote{\shorturl{https://}{dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine}}

In short, academic researchers are working to close the performance gap
without overly restricting the promise of gradual typing.
Industry researchers are sidestepping the problem with unsound types---for the most part.

This paper reports on a remarkable exception to the rule among industry-made gradual type systems.
The \SP{} team at Instagram has developed a sound type system for a subset of
Python along with a runtime system designed to
capitalize on the benefits of sound types.
The language design is a variation of concrete types that lets programmers
begin with shallow claims about data structures and gradually opt in to deeper soundness.
Remarkably, the performance of Python is an upper bound on the observed performance of
Static Python.


\paragraph*{Contributions}

\begin{itemize}
  \item
    Evidence that gradual soundness delivers fast performance incrementally,
    as programmers migrate to sound types.
    \SP{} can be applied to a codebase with no refactoring and no performance overhead.
    After refactoring to sound types, \SP{} performs well on a microbenchmark
    suite and in production.
  \item
    A formal description and analysis of the \SP{} core language.
    The analysis includes a proof of type soundness,
    a proof that optimization soundly improves code,
    and [FILL perhaps] a metric to quantify the refactoring cost and optimization benefit
    of a type migration.
  \item
    A list of the expressiveness limitations in \SP{} relative to
    idealized gradual type systems,
    and an informal description of the programming discipline that Instagram
    follows in their gradually-sound codebase.
\end{itemize}


\paragraph*{Significance}

We have written this paper with two audiences in mind.
First, we want to encourage system-builders to reproduce the compelling
\SP{} language design in another context and measure performance.
Second, we want to lend focus to theoretical research on gradual typing.
The restrictions that \SP{} adopts (relative to the ideal promise of gradual typing)
may be worthwhile assumptions for theory going forward.
On the flip side, future research may find a way to lift restrictions
that \SP{} currently adopts.


\section{\SP{} and the Cinder JIT}
\label{s:tour}
%% purpose = SP looks like Pyre, adds soundness to certain types

\SP{} is a type checker and bytecode compiler.
It validates programs written in ordinary Python syntax
and generates type-specific bytecode for the Cinder JIT compiler.
Cinder is a fork of CPython 3.8 that introduces a method-based
JIT and several bytecode instructions.

Running \SP{} code is no different than standard Python.
The main Cinder executable generates bytecode and performs
optimizations on the fly, same as CPython.

There are a few restrictions on classes
and a few optional types that programmers may wish to use,
but otherwise Python programs can run via \SP{}.
%% TODO awk


\subsection{Example Program}

\begin{figure}
  %% TODO replace with a real program
%  \begin{minipage}[t]{0.5\columnwidth}
  \begin{verbatim}
    from __static__ import PyDict

    def f(x: PyDict[str, int]):
      return x["A"]

    f({"A": 1}) # ==> 1
  \end{verbatim}
%  \end{minipage}\begin{minipage}[t]{0.5\columnwidth}
%  \begin{verbatim}
%    from __static__ import PyDict
%
%    def f(x: PyDict[str, int]):
%      check_args(x, PyDict)
%      return cast(x["A"], int)
%
%    invoke_function(f, {"A": 1}) # ==> 1
%  \end{verbatim}
%  %  ....
%  %  CHECK_ARGS
%  %  ....
%  %  INVOKE_FUNCTION
%  \end{minipage}
%  \begin{verbatim}
%    from __static__ import CheckedDict
%
%    def f(x: CheckedDict[str, int]):
%      return x["A"]
%
%    f(CheckedDict({"A": 1}))
%  \end{verbatim}
  \caption{A first \SP{} program}
  \label{fig:sp-example}
\end{figure}

\Cref{fig:sp-example} (left) presents a first example program
that defines a function \code{f} and calls it from typed code.
The syntax is normal Python with type annotations.
Only the import statement makes special use of \SP{};
it imports a type \code{PyDict} that describes Python dictionaries.

Although this program is typed, a different untyped module is free
to import the function \code{f} and invoke it with any sort of
argument.
For this reason, the compiled version of \cref{fig:sp-example} must
include a few run-time casts:
\begin{itemize}
  \item
    The function \code{f} must check that its arguments match the \code{PyDict} domain annotation.
    Concretely, this check accepts any dictionary.
  \item
    Because the domain check does not validate the contents of an incoming dictionary,
    the dict access must check that its result matches the function codomain.
\end{itemize}
These checks ensure a kind of type soundness.

\SP{} also uses types to drive optimizations.
Because the call to \code{f} in \cref{fig:sp-example} appears in typed code,
there is no need to check that it sends type-correct inputs.
Thus, the compiled call uses a Cinder bytecode instruction to skip past the
domain check and immediately enter the function body.

The tension between checks that enforce soundness and optimizations allowed by soundness
is a central theme of \SP{}.


\subsection{Language Pipeline}


\begin{enumerate}
  \item Pyre as an optional, but recommended pre-check. (Not necessary for the model.)
  \item SP type checker
  \item Custom bytecode, Cinder JIT
\end{enumerate}


\subsection{Type Dynamic}

The dynamic type is an important part of Static Python.
Dynamic avoids the need for whole-sale migration,
lets programmers work around dynamic features like splatting,
and is in some cases necessary for optimal performance (evidence?).


\subsection{Checked Types}

%% more to say about the style of migration in SP?

Enabling sound types on a function has a ripple effect on callers.
All untyped callers are now forced to supply type-correct inputs; may call for
refactoring.

Enabling checked types has a huge ripple effect.
The worst case is changing an annotation to a expect a checked data structure:
\begin{enumerate}
  \item all callers must create a checked value by invoking the right constructor, and
  \item all clients of those callers can no longer expect an unchecked type.
\end{enumerate}
Programmers have to trace the annotation back to value-creation points, and then
ensure that all uses of those values are compatible.


\subsection{Restrictions}

No overloading.
At most one method per class and name.
Ensures that receiver type does not affect dispatch.

Overrides must be compatible, if done in static code.
What's the reason?



\subsection{Additional Options}

strict modules

decorator to force inlining, for 1-line functions



\section{Model}
\label{s:model}
%% purpose = types, checks, and optimizations can be formalized and analyzed


\subsection{Goals and Limitations}

The designers of Static Python hope to eventually build a system that is sound for arbitrary Python code,
but are not there yet.
The known side channels include:
eval, the locals and globals dicts (the latter can be accessed through frame objects at the moment),
and mutable closure cells.
Our model does not cover these either.
We essentially ban all these features, rejecting any program in which they appear.
Code mining in JS (and perhaps the newer R work?) suggests that at least eval
uses can be rewritten without too much pain. The few exceptions would point
to language weaknesses / call for new semantically-descriptive features.

FILL do we stop at strict modules?\footnote{https://instagram-engineering.com/python-at-scale-strict-modules-c0bb9245c834}
A strict module is 100\% repeatable and isolated from the side effects of other modules.



\subsection{Surface Language}


\subsection{Evaluation Language, Optimizations}


\subsection{Bug Reports}

While formalizing Static Python, we submitted N bug reports to the language developers.
The developers acknowledged M of these bugs as issues to fix.


\section{Under the Hood: Static Python Specifics}
\label{s:impl}

Purpose: explain significant gaps between the model and the implementation.
E.g. what would the TypeScript team need to know before using our model
to add soundness?


\section{Evaluation}
\label{s:eval}


\subsection{Benchmarks}


\subsection{Production Experience}


\section{Related Work}

Nom~\cite{mt-oopsla-2017} is foundational.
Thorn~\cite{wnlov-popl-2010} and StrongScript~\cite{rzv-ecoop-2015} are related.

PyPy is another runtime for Python
Pycket is built on PyPy and improves both Typed Racket~\cite{bbst-oopsla-2017}
and Reticulated Python~\cite{vsc-dls-2019}.


\section{Future Work}

Adapt SP ideas to a new setting, test performance takeaways.

Improve SP with generic types, structural types (lambda), \ldots.

Build an automatic migration tool for Checked data.

Build a static analysis that hoists transient annotations to an early, shared point.
Take care to give quality error messages.


\section{Conclusion}
\label{s:conclusion}

Sound types in Static Python give programmers a way to improve performance.
The change is not forced, not intrusive;
programmers can keep using unsound types when working toward a deadline.

Conjecture that soundness will find bugs too, and lead to more reliable products.
Too soon to say.


\subsection{Communication}

How did we communicate effectively?
Starting point was GT survey [CITE].
Moved forward with example programs, see emails and github issues.
Our formalism had to cover their unit tests.
FILL


\bibliography{bg}

%\appendix

\end{document}
