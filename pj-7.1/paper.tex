\documentclass[english,cleveref,submission]{programming}

%% Thesis:
%%  1. Static Python is sound, fast, and practical
%%  2. SP has unique features and restrictions for speed
%%  3. Gradual soundness is a feature: start with weak types and eventually migrate to checked types

% > Here’s the thing: I think this is the sort of thing an academic might say “oh,
% > this is too much work, it’d never work” But in fact it looks like they seem to
% > be making it work -- Shriram 2021-09-30

%% TODO before submission
%% - choose words: static vs typed, nonstatic vs dynamic vs untyped
%%   trying to avoid nonstatic? staticifying?
%% - terms: sound generic / concrete ... aren't people going to forget concrete? better keep as last resort
%% - perhaps a compatibility story, programmers can work on Python 3.9 until Cinder catches up b/c source code is the same

%% TODO after submission, before camera-ready
%% - 

\newcommand{\shorturl}[2]{\href{#1#2}{#2}}
\newcommand{\SP}{Static Python}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\bcinst}[1]{\code{#1}}
\newcommand{\defeq}{=}
\newcommand{\mfeq}{=}
\newcommand{\langmid}{\mid} %% {\mathrel{\mathbf{\Big\vert}}}
\newenvironment{langarray}{\(\def\arraystretch{1.5}\begin{array}{l@{\hspace{2mm}}c@{\hspace{2mm}}l}}{\end{array}\)}
\newcommand{\ipara}[1]{\emph{#1}\/.}

\newcommand{\numbenchmark}{2}
\newcommand{\CPUchange}{3.7\%}

\newcommand{\spapp}[2]{#1\,(#2)}
\newcommand{\spann}[2]{#1\!:\!#2}
\newcommand{\bmname}[1]{\textbf{#1}}
\newcommand{\typefont}[1]{\mathsf{#1}}
\newcommand{\codefont}[1]{\emph{#1}}
\newcommand{\paramtype}[2]{#1[#2]}
\newcommand{\sptype}{\typefont{T}}
\newcommand{\spteval}{\typefont{S}}
\newcommand{\sptclass}{\typefont{C}}
\newcommand{\sptX}{\typefont{X}} %% undefined type for an early example
\newcommand{\sptint}{\typefont{Int}}
\newcommand{\sptstr}{\typefont{Str}}
\newcommand{\sptbool}{\typefont{Bool}}
\newcommand{\sptfloat}{\typefont{Float}}
\newcommand{\sptflout}{\typefont{Flout}}
\newcommand{\sptdyn}{\typefont{Dyn}}
\newcommand{\sptobject}{\typefont{Object}}
\newcommand{\sptnone}{\typefont{None}}
\newcommand{\sptinstanceof}[1]{\paramtype{\typefont{Instance}}{#1}}
\newcommand{\sptoptional}[1]{\paramtype{\typefont{Optional}}{#1}}
\newcommand{\sptset}[1]{\paramtype{\typefont{Set}}{#1}}
\newcommand{\sptunion}[1]{\paramtype{\typefont{Union}}{#1}}
\newcommand{\sptrawpydict}{\typefont{PyDict}}
\newcommand{\sptrawchkdict}{\typefont{ChkDict}} %% not a real SP type, but useful for TeX
\newcommand{\sptpydict}[2]{\paramtype{\sptrawpydict}{#1, #2}}
\newcommand{\sptchkdict}[2]{\paramtype{\typefont{ChkDict}}{#1, #2}}
\newcommand{\sptenv}{\typefont{Env}}
\newcommand{\sptenvnil}{\cdot}
\newcommand{\sptenvempty}{\sptenvnil}
\newcommand{\sptvardef}[2]{\spann{#1}{#2}}
\newcommand{\sptfundef}[3]{\spapp{#1}{#2}\code{ -> }#3}
\newcommand{\sptclassdef}[4]{\mathrm{class}~\spapp{#1}{#2}:~#3;~#4}
\newcommand{\trule}[1]{\textsc{#1}}

\newcommand{\spx}{\code{x}}
\newcommand{\spf}{\code{f}}
\newcommand{\spc}{\sptclass}
\newcommand{\spprog}{\codefont{prog}}
\newcommand{\spstmt}{\codefont{stmt}}
\newcommand{\spexpr}{\codefont{expr}}
\newcommand{\spvalue}{\codefont{val}}
\newcommand{\vdashsub}[1]{\vdash_{#1}}
\newcommand{\wtprog}{\vdashsub{\mathbf{P}}}
\newcommand{\wtexpr}{\vdashsub{\mathbf{E}}}
\newcommand{\wtsub}{\vdash}
\newcommand{\spsubt}{\mathrel{<:}}
\newcommand{\spsubteq}{\mathrel{\leq:}}
\newcommand{\spcompat}{\sqsubseteq}
\newcommand{\spconsist}{\spcompat}
\newcommand{\spmatr}{\prec}
\newcommand{\spvardef}[3]{\sptvardef{#1}{#2} = #3}
\newcommand{\spfundef}[4]{\mathrm{def}~\spapp{#1}{#2}\code{ -> }#3: #4}
\newcommand{\spclassdef}[4]{\mathrm{class}~\spapp{#1}{#2}:~#3;~#4}
\newcommand{\spself}{\code{self}}
\newcommand{\spobject}{\code{object}}
\newcommand{\spnone}{\code{none}}
\newcommand{\spint}{\codefont{int}}
\newcommand{\spbool}{\codefont{bool}}
\newcommand{\spfloat}{\codefont{float}}
\newcommand{\sppydict}[1]{\code{\{}#1\code{\}}}
\newcommand{\spchkdict}[3]{\spapp{\paramtype{\code{chkdict}}{#1, #2}}{#3}}
\newcommand{\spenvapp}[2]{\spapp{#1}{#2}}
\newcommand{\spdictref}[2]{#1[#2]}
\newcommand{\spdictset}[3]{\spdictref{#1}{#2} = #3}
\newcommand{\spobjref}[2]{#1.#2}
\newcommand{\spobjset}[3]{\spobjref{#1}{#2} = #3}
\newcommand{\spobjapp}[3]{\spobjref{#1}{\spapp{#2}{#3}}}

\newcommand{\sprred}{\rightarrow^*}

\newcommand{\mfapply}[2]{#1\,(#2)}
\newcommand{\mffont}[1]{\mathit{#1}}
\newcommand{\mftypeF}[1]{\mfapply{\mffont{F}}{#1}} % {\mfapply{\mffont{T}_{\downarrow}\!\mffont{S}}{#1}}
\newcommand{\mfcast}[2]{\mfapply{\mffont{Cast}}{#1, #2}}
\newcommand{\mfopt}[1]{\mfapply{\mffont{opt}}{#1}}

\newcommand{\sperror}{\mathrm{Error}}

%\overfullrule=1mm

%\usepackage{draftwatermark}
%\SetWatermarkText{DRAFT}
%\SetWatermarkScale{1}

%% BEGIN tobias pape 2021-11-06
\makeatletter
\newcommand*\abstractpart[1]{\leavevmode\unskip\par\noindent{\firamedium\color{P@GrayFG}{#1}}\enspace}
\makeatother
%% END

\usepackage{lscape}
\usepackage[framemethod=TikZ]{mdframed}
\newmdenv[roundcorner=2pt,linewidth=0.4pt,linecolor=Black]{spcodebox}
\usepackage{amsthm}
\usepackage{mathpartir}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage[backend=biber]{biblatex}
\addbibresource{bg.bib}

\begin{document}

\title{Gradual Soundness: Lessons from Static Python}
%% ... types make things fast?
%% ... gradual migratory progressive soundness

%\titlerunning{short title}

\author[a]{Kuang-Chen Lu}
\authorinfo{(\email{LuKuangchen1024@gmail.com}) is a PhD student at Brown University.}
\affiliation[a]{Brown University, Providence, RI, USA}
\author[a]{Ben Greenman}
\authorinfo{(\email{benjamin.l.greenman@gmail.com}) is a PLT member and a postdoc at Brown University.}
\author[b]{Carl Meyer}
\authorinfo{(\email{carljm@fb.com}) FILL}
\affiliation[b]{Meta, Menlo Park, CA, USA}
\author[b]{Dino Viehland}
\authorinfo{(\email{dinoviehland@fb.com}) FILL}
\author[a]{Shriram Krishnamurthi}
\authorinfo{(\email{shriram@brown.edu}) is the Vice President of Programming Languages (no, not really) at Brown University.}

%\authorrunning{K-C. Lu, B. Greenman, C. Meyer, D. Viehland, S. Krishnamurthi}

\keywords{gradual typing, migratory typing}

\begin{CCSXML}
\end{CCSXML}
% \ccsdesc[100]{FILL}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\paperdetails{
  %% perspective options are: art, sciencetheoretical, scienceempirical, engineering.
  perspective=scienceempirical,
  %% State one or more areas, separated by a comma. (see 2.2)
  %% Please see list of areas in http://programming-journal.org/cfp/
  %% The list is open-ended, so use other areas if yours is/are not listed.
  area={General-purpose programming},
  %% License options include: cc-by (default), cc-by-nc
  % license=cc-by,
}

\maketitle

\begin{abstract}
  \let\paragraph\abstractpart

  \vglue10pt

  \paragraph{Context}
  % What is the broad context of the work? What is
  % the importance of the general research area?
  Gradually-typed languages allow typed and untyped code to interoperate,
  but typically come with significant drawbacks.
  In some languages, the types are unreliable;
  in others, communication across type boundaries can be extremely expensive;
  and still others allow only limited forms of interoperability.
  The research community is actively seeking a sound, fast, and expressive
  approach to gradual typing.

  \vglue10pt

  \paragraph{Inquiry}
  % What problem or question does the paper
  % address? How has this problem or question been
  % addressed by others (if at all)?
  This paper describes \SP{}, a language developed by engineers at Instagram
  that has proven itself sound, fast, and reasonably expressive in production.
  \SP{}'s approach to gradual types is essentially a programmer-tunable combination of
  the \emph{concrete}\/ and \emph{transient}\/ approaches from the literature.
  Concrete types provide full soundness and low performance overhead, but impose
  nonlocal constraints.
  Transient types are sound in a shallow sense and easier to use; they help
  to bridge the gap between untyped code and typed concrete code.

  \vglue10pt

  \paragraph{Approach}
  % What was done that unveiled new knowledge?
  We evaluate the language in its current state
  and develop a model that captures the essence of its
  approach to gradual types.
  We draw upon personal communication, bug reports, and the \SP{}
  regression test suite to develop this model.

  \vglue10pt

  \paragraph{Knowledge}
  % What new facts were uncovered? If the
  % research was not results oriented, what new
  % capabilities are enabled by the work?
  Our main finding is that the \emph{gradual soundness}\/ that
  arises from a mix of concrete and transient types is an effective
  way to lower the maintenance cost of the concrete approach.
  We also find that method-based JIT technology can eliminate the
  costs of the transient approach.
  On a more technical level, this paper contributes two artifacts:
  a model of \SP{} that passes property-based tests and hundreds of tests from the \SP{} codebase,
  and a performance evaluation of \SP{}. The process of formalization
  found several errors in the implementation, including fatal errors.

  \vglue10pt

  \paragraph{Grounding}
  % What argument, feasibility proof, artifacts,
  % or results and evaluation support this work?
  Our model of \SP{} is implemented in PLT Redex and tested using
  property-based soundness tests and the \SP{} regression suite.
  This paper includes a small core of the model to convey the main ideas
  of the \SP{} approach and its soundness.
  Our performance claims are based on production experience in the Instagram
  web server.
  Thanks to \SP{}, global CPU usage has improved by \CPUchange{} within a year.

  \vglue10pt

  \paragraph{Importance}
  % Why does this work matter?
  \SP{} is the first sound gradual language whose piece-meal application
  to a realistic codebase has consistently improved performance.
  %% Prior work on Nom and Dart 2 showed that concrete types are promising.
  Other language designers may wish to replicate its approach,
  especially those who currently maintain unsound gradual languages and are
  seeking a path to soundness.

\end{abstract}


\section{Introduction}
%% alt title:
%%  {A Staged Gradual Language}
%%  {Typing for Performance}
\label{s:intro}

Gradual typing has attracted significant interest as a solution to
the debate between static and dynamic typing.
The premise is simple: let programmers introduce types in part of a
codebase and while leaving the rest untyped.
Run-time checks enforce the critical assumptions that typed code makes about
untyped components, thereby ensuring that the types are sound no matter how
untyped code behaves.

Unfortunately, the high run-time cost of sound types has split
the gradual typing community.
Industry teams have developed innovative type systems that accommodate
untyped designs, but are unsound~\cite{bat-ecoop-2014,rch-popl-2012,cvgrl-oopsla-2017}.
These systems intentionally check nothing at run-time when untyped values enter
typed code.
Academic teams have primarily focused on the theory of sound
gradual types, formulating correctness properties and studying ever-more-descriptive
types~(e.g.~\cite{sgt-jfp-2016,clps-popl-2019,nla-popl-2019,mgt-oopsla-2021})
A few academics have studied the cost of run-time checks
in detail~\cite{tfgnvf-popl-2016,gtnffvf-jfp-2019}
and proposed implementation methods~\cite{kas-pldi-2019,bbst-oopsla-2017},
compiler technology~\cite{vsc-dls-2019,fgsfs-oopsla-2018},
and even weakened semantics~\cite{glfd-pj-2022,vss-popl-2017,gi-scp-2020},
but these efforts have not yet decisively closed the performance gap.
The most promising attempt is the \emph{concrete} semantics
for gradual types~\cite{clzv-ecoop-2018,mt-oopsla-2017,wzlov-popl-2010}, but it imposes nonlocal
constraints on untyped code.
In particular, concrete-typed client code is incompatible with
values created by untyped code.
Rather than search for a coordinated set of edits to make concrete
types work, developers may prefer a whole-sale migration to
a typed language.\footnote{Successful migrations of untyped codebases
to a typed language are rare, but not unheard of.
Twitter ported its server-side code from Ruby to Scala~\cite{twitter-scala}
and Dropbox moved its core sync engine from Python mypy to Rust~\cite{dropbox-rust}.}

In short, academic researchers are working to close the performance gap
without overly restricting the promise of gradual typing.
Industry researchers are sidestepping the problem with unsound types---for the most part.

This paper reports an exception to the rule among industry-made gradual type systems.
The \SP{} team at Instagram has developed a \emph{sound} type system for a subset of
Python along with a runtime system that uses soundness to drive optimizations.
The language is staged to let programmers choose between easy migrations and
full-strength optimizations, a design that we call \emph{gradual soundness}.
To a first approximation, there are three main stages:
\begin{enumerate}
  \item
    \SP{} contains a full language of \emph{shallow types}\/ that describe idiomatic
    Python code at a coarse granularity.
    Adapting an untyped module to use shallow types requires at most a few local code
    changes.
  \item
    A small set of \emph{concrete types}\/ describe generic data structures
    that guarantee the types of their elements.
    If programmers modify their code to build concrete structures instead of Python
    ones (a potentially nonlocal change), then \SP{} can speed up reads from these
    structures.
  \item
    Additional types and flags to enable further optimizations.
    These include \emph{primitive types}\/ that enable unboxed arithmetic
    and \emph{strict module semantics}\/ that makes modules immutable.
\end{enumerate}

Over the past year, Instagram has been applying gradual soundness to its
primary web server monolith.
The results are very positive.
Although only a handful of modules use \SP{} types (hundreds among thousands),
and only a few critical modules rely on concrete types and primitive types (dozens),
global CPU usage has improved by \CPUchange{} according to internal profiling tools.
Type-directed optimizations outweigh the cost of enforcing soundness.
Consequently, we believe the details of the \SP{} approach are of interest to
the gradual typing community at large.


\paragraph*{Contributions}
This paper makes two contributions:

\begin{itemize}
  \item
    \emph{Evidence}.
    We present evidence that \SP{} improves performance with few code changes.
    At Instagram, the web server has become significantly more efficient
    after the application of \SP{} to high-profile modules.
    Because the server code is closed-source, we additionally present data for
    \numbenchmark{} public benchmarks.
    Using only shallow types, \SP{} runs on-par with Python despite the costs of
    enforcing soundness.
    With fine-tuned types, \SP{} consistently out-performs the Python baseline.

  \item
    \emph{Mechanization}.
    To validate the soundness of \SP{}, we mechanized a core language in PLT Redex
    and ran both property-based soundness tests and over 200 tests adapted from the \SP{} regression suite.
    The model brings across the essence of \SP{} and lends support to the claim
    that core \SP{} is indeed sound.
    Perhaps more importantly, the \emph{process} of modeling revealed 20 significant
    issues in \SP{}.
    Four of these were critical soundness bugs.

\end{itemize}

\paragraph*{Outline}

This paper begins with an informal description of \SP{} in two parts.
First, we present a user-oriented summary of the language~(\cref{s:tour}).
Second, we present the key ingredients of the runtime system, Cinder,
that supports \SP{}~(\cref{s:runtime}).
\Cref{s:model} uses a small formal model to introduce our Redex mechanization
and to convince readers that \SP{} is based on a sound core.
\Cref{s:impl} notes important aspects of \SP{} that are not covered by the model.
\Cref{s:eval} evaluates \SP{}; it reports our experience with the language in
production and on public microbenchmarks.
The paper concludes with related work~(\cref{s:related})
and a final summary~(\cref{s:conclusion}).


\paragraph*{Significance}

We have written this paper with two audiences in mind.
First, we want to encourage system-builders to reproduce the
\SP{} language design.
In particular, the maintainers of optionally-typed languages
may wish to focus on shallow types and JIT compilation as a
first step toward sound gradual types.
Second, we want to entice researchers.
The \SP{} type system has many restrictions that are suprising
at first glance.
For example, functions are supported only by shallow types
and method overrides that use the dynamic type are more constrained
than overrides in untyped code.
Some of these restrictions might be lifted by future research.
Others might be useful to adopt in new language designs.


\section{A Tour of \SP{}}
\label{s:tour}
%% purpose = SP looks like Pyre, adds soundness to certain types

% {Language Pipeline}
% \begin{enumerate}
%   \item Pyre as an optional, but recommended pre-check. (Not necessary for the model.)
%   \item SP type checker
%   \item Custom bytecode, Cinder JIT
% \end{enumerate}

\SP{} is part of a large codebase that includes a type system, a tailored
bytecode, and a method-based JIT compiler.
In essence, \SP{} is a type system for a new language.
The interface that it offers to programmers, however, seeks to replicate the
Python experience.
\SP{} runs untyped Python 3.8 programs with minimal changes to their behavior,
and it compiles code on-the-fly to give the same workflow and enable the same
developer tools as standard Python.
The advanced features of the \SP{} type system are offered on an opt-in basis
and arranged so that programmers can begin adding types one module at a time.

%% TODO clean up arrow between subfigs
\begin{figure}
  \begin{subfigure}[t]{0.15\columnwidth}\noindent\begin{lstlisting}

def f(x):
  return x["A"]

f({"A": 1})
  \end{lstlisting}
\end{subfigure}\(~~\rightarrow~~\)\begin{subfigure}[t]{0.32\columnwidth}\noindent\begin{lstlisting}
from __static__ import PyDict
def f(x: PyDict[Str, Int]):
  return x["A"]

f({"A": 1})
  \end{lstlisting}
  \end{subfigure}\(~~\rightarrow~~\)\begin{subfigure}[t]{0.34\columnwidth}\noindent\begin{lstlisting}
from __static__ import ChkDict
def f(x: ChkDict[Str, Int]):
  return x["A"]

f(chkdict[Str, Int]({"A": 1}))
  \end{lstlisting}
  \end{subfigure}

  \caption{A first \SP{} program and two migrations}
  \label{fig:sp-example}
\end{figure}

\Cref{fig:sp-example} presents a first example program and two modified versions that
utilize \SP{} types.
The basic program defines a function \code{f} and calls it with a dictionary
value.
\SP{} can run this program as-is and even JIT-compile the function.
The other two versions import dictionary types from the \SP{} standard library:
\begin{itemize}
  \item
    The $\sptrawpydict$ type describes normal Python dictionaries in a \emph{shallow} sense.
    At compile-time, \SP{} uses this type to check the program for logical errors.
    At run-time, \SP{} enforces the type by checking that all inputs to \code{f} are
    dictionary values.
    These checks enable optimizations within the function body.

  \item
    The $\sptrawchkdict$ type describes a \emph{concrete} dictionary data structure provided by \SP{}.
    Unlike Python dictionaries, these checked dictionaries are guaranteed to
    contain well-typed keys and values even if they escape to untyped code.
    As the body of \code{f} illustrates, the syntax for using a checked dict is standard.
    Creating a checked dict, however, requires a parameterized constructor call.
\end{itemize}
These typed versions demonstrate the multi-level nature of the \SP{} interface.
At one level, there are types that describe standard Python values that can be added
to a program with little-to-no code changes.
Beyond that, \SP{} offers special-purpose types with stronger guarantees that impose
nonlocal maintenance costs (i.e., on constructor calls).


\subsection{Type System Context and Design Goals}

The \SP{} type system is a unique synthesis of ideas from the gradual typing literature
and prior work on types for Python.
Nom~\cite{mt-oopsla-2017,mt-oopsla-2021} and PEP 484~\cite{pep484} are two notable sources.
In addition, \SP{} is strongly influenced by the following engineering constraints:
\begin{itemize}
  \item
    Performance is the bottom line.
    At the end of the day, \SP{} needs to make code run faster in production.
  \item
    Critical code often relies on first-order functions and objects,
    at least in the Instagram web server.
    Precise types for higher-order functions and first-class classes
    are thus a low priority.
  \item
    The codebase in which \SP{} is being applied makes heavy use of Pyre~\cite{pyre}
    type annotations.
    \SP{} needs to be compatible with Pyre syntax to reduce the adoption burden.
    % On the flip side, the existence of Pyre lets \SP{} focus on a small language
    % of types that enable optimizations.
    % depth-first types.
    % (\SP{} defers to Pyre the task of statically checking the full Python language.)
  \item
    A module-level granularity is acceptable.
    Once \SP{} is enabled for a module, it compiles all code in that module
    including expressions that have the dynamic type~(\cref{s:type-dynamic}).
    If this behavior is a problem for certain expressions, it is easy enough to move
    them to an untyped Python module.
\end{itemize}
%
In general, the types that \SP{} implements all enable significant optimizations
and can be validated with constant-time dynamic checks.
Types that do not meet these criteria are deferred to Pyre, even if they are widely-used.

At present, \SP{} has no plans to support all Pyre types.
The goal is to implement a small language of types efficiently.
After all, programmers can always lint their code with Pyre before running
\SP{}.

The core supported types describe basic data (integers, booleans, strings),
data structures (lists, dicts, promises),
and nominal classes.
Union types are well-supported statically and narrow down in accordance
with type tests (a form of occurrence typing~\cite{tf-icfp-2010,gsk-esop-2011}),
but are, for the most part, not supported at run-time.
Only binary unions of a type and the Python \code{None} value get enforced with a run-time check
($\sptunion{\sptype, \sptnone}$, or $\sptoptional{\sptype}$).

Three other unsupported types bear special mention:
first-class class and object types~(\cref{s:inheritance});
first-class function (callable) types; and
recursive types.
Pyre has some support for the first two, but not for recursive types.
In any event, the demand for all three types is low in our applications
of \SP{}.
%% mypy = https://github.com/python/mypy/issues/731
%% nothing in pep 484 = https://www.python.org/dev/peps/pep-0484/


\subsection{Type Dynamic}
\label{s:type-dynamic}

%% 2021-12-14 TODO:
%% - anything to say about Any being a "meta" type in Python typing module?
%%   2022-01-10 bg: not sure what the consequences of "meta type" are

Like most gradual languages, \SP{} includes a dynamic type
that allows untyped expressions within a statically-typed context.
Whenever an expression or variable lacks a type annotation, \SP{} uses the
dynamic type as a default and skips most \emph{but not all\/} static checks.
Programmers can thus add annotations to part of a module
while leaving the rest unannotated.

In addition to serving as a default, the dynamic type also replaces any undefined types.
For example, suppose that the type $\sptflout{}$ is undefined in \SP{}
(i.e. it is a misspelling of $\sptfloat$) and that a
program contains the annotation $\sptchkdict{\sptstr}{\sptflout}$, which describes a
dictionary with integer keys and $\sptflout$-typed values.
\SP{} interprets this annotation as $\sptchkdict{\sptint}{\sptdyn}$ and allows any sort
of values inside the dictionary at runtime.

At first glance, this behavior might seem odd: why not reject undefined types with an error?
The reason is to reduce friction with existing Pyre annotations.
Pyre is a mature static type system that can check more types than \SP{} knows how to enforce
efficiently, e.g., the type $\sptset{\sptint}$ for sets of integers.
By replacing such types with dynamic, \SP{} can accept Pyre code that it does not yet fully understand.

The \SP{} dynamic type is also different than the flexible dynamic type provided
by gradual languages that satisfy the gradual
guarantees~\cite{svcb-snapl-2015}.
In \SP{}, replacing part of a type with dynamic can lead to a static error when
the compiler analyzes that part of the module.
Similarly, the addition of a dynamic type can lead to a run-time error because of the
strict checks that \SP{} applies to generic types.
\Cref{fig:gg-failure} presents two examples, one for each kind of failure:
%% \footnote{Technically, \SP{} does not even
%% have syntax for the dynamic type. The idiomatic way to ask for dynamic is to
%% omit a type annotation.}
%% \footnote{We
%% assume a standard type precision relation. Of course, one could argue that these programs
%% do not break the gradual guarantees for a type precision relation that is tailored to \SP{}.}
%%   %% tailored = describes exactly the migrations that SP allows
%% \footnote{In addition, C types~(\cref{s:c-types}) are incompatible with type dynamic.}
\begin{itemize}
  \item
    \Cref{f:gg-failure-stat} presents a fully-typed class and a partially-typed subclass.
    The subclass definition raises a compile-time error because it attempts to override
    the typed \code{m} method to return the dynamic type.

  \item
    \Cref{f:gg-failure-dyn} sends a checked dictionary with integer values to a
    function that expects dictionaries with dynamic values.
    At runtime, the function rejects this argument because its type is not an
    exact match.
\end{itemize}
These behaviors enable efficient run-time checks and additional type-directed
optimizations.
Part of the reason \SP{} weighs these benefits more heavily than the costs
is that programmers have to opt-in to a feature in order to risk the errors.
The static error above comes only after enabling the \SP{} compiler on a module.
The dynamic error comes only after adopting a concrete type (for checked dictionaries).

More to the point, \SP{} has little interest in guarantees about
\emph{removing an arbitrary annotation}.
It is, however, very interested in making sure that \emph{an untyped
module compiles with minimal code changes}.

\begin{figure}
  \begin{subfigure}[t]{0.48\columnwidth}
    \begin{lstlisting}
class A:
  def m(self) -> Int:
    return 0

class B(A):
  def m(self):
    # Error: Dyn cannot override Int
    return 0
  \end{lstlisting}
    \caption{SGG Violation: removing a type in the subclass \code{B} raises a static error}
    \label{f:gg-failure-stat}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.48\columnwidth}
  \begin{lstlisting}
from __static__ import ChkDict

def f(x: ChkDict[Str, Dyn]):
  return x["A"]

d = ChkDict[Str, Int]({"A": 1})
f(d)
# Error: f expected ChkDict[Str, Dyn]
  \end{lstlisting}
    \caption{DGG Violation: removing part of the type for the parameter \code{x} raises a dynamic error}
    \label{f:gg-failure-dyn}
  \end{subfigure}
  \caption{\SP{} ensures neither the static (SGG) nor the dynamic (DGG) gradual guarantees}
  \label{fig:gg-failure}
\end{figure}

%% TODO carl 2021-12-24 ... very important to introduce machine types with ChkDict ... emphasizes that the GG is not necessary, but only nice-to-have
%% > One area where we definitely violate the gradual guarantee and always will
%% > is primitive machine types. Unlike Python object types these do not flow to
%% > dynamic, and dynamic can never flow to them! Effectively they form a
%% > fully-typed subset of the type system that does not participate in gradual
%% > typing and can never occur in non-static code. So this violates GG because
%% > there are many examples where removing an annotation of a primitive machine
%% > type can cause static code to no longer type check.


\subsection{Concrete Types and Shallow Types}
\label{s:checked-type}

Every \SP{} type corresponds to a constant-time dynamic check.
When an unknown value reaches a boundary to typed code at run-time,
\SP{} uses these checks to quickly decide whether or not the value
matches the type (think: \code{isinstance} checks).
Unlike structural gradual type systems, \SP{} does not traverse
incoming values nor does it create wrappers to enforce behavior.

These dynamic checks try to faithfully enforce a full type, but some are incomplete---especially
for generic types.
We call the incomplete ones \emph{shallow} types.
The \SP{} strategy for fully-sound generics is to package each value with a type
tag; following the \textsf{StrongScript} authors~\cite{rzv-ecoop-2015}, we call
these \emph{concrete} types.

First off, for a basic nominally-typed language (think Java 1.4, before
generics), constant-time checks are easy to implement.
Every type has a name and every value can carry a tag that corresponds to the
name of its type.

Parameterized types (generics) are more difficult to enforce.
Consider a dictionary datatype \code{Dict[K,V]} that is parameterized by types
for its keys and values.
If a function expects a dict from integers to integers (\code{Dict[Int,Int]}),
then merely checking for a dict instance is not enough to decide whether an
incoming value matches the type.
For example, the incoming value may have been created by untyped code.

The \SP{} solution is to provide two incompatible versions of every parameterized type,
both of which support efficient run-time checks.\footnote{Currently, only a handful of built-in data structures provide shallow
and concrete versions. User-defined classes will soon follow this approach.}
For dictionaries, \SP{} provides the types $\sptrawpydict$ and $\sptrawchkdict$:
\begin{enumerate}
  \item
    \emph{Shallow type $\sptrawpydict$}.
    The default type $\sptrawpydict$ gets enforced with a constant-time check
    for dict values that ignores the elements inside a dict.
    Consequently, a parameterized static type such as $\sptpydict{\sptint}{\sptint}$
    is merely a promise of dict values at run-time; it does not promise anything about
    dict keys and values.
  \item
    \emph{Concrete type $\sptchkdict{\sptype}{\sptype}$}.
    \SP{} introduces a parameterized type for concrete, checked dictionaries
    along with a value constructor that records its type constraints.
    \cref{s:chkdict-impl} discusses the implementation further.
\end{enumerate}
%
These options let programmers decide whether to edit their code to support concrete types
or leave it as-is with shallow types.
Often, the shallow types are more attractive because concrete types impose
nonlocal changes.
If one type changes to concrete, then all data constructors that reach this type need
to change \emph{and} all their clients need to use the concrete type as well.

The upside of concrete types is that they enforce stronger type constraints.
These constraints can catch bugs and usually lead to more-efficient code.
Faster performance is not guaranteed, though, because it depends on how the dict
gets used.
\Cref{t:shallow-vs-concrete} presents a detailed comparison.
Shallow types pay a constant-time cost whenever an untyped value enters typed code
and whenever a typed context reads from a shallow value.\footnote{The predicted
costs for reads and writes assume that all \SP{} types can be validated with a
constant-time check.}
The net cost of reads may be high.
Concrete types pay a potentially-high cost for constructors,
a constant-time cost for casts and for writes,
and zero cost for dereferences.
If a value is frequently written to and rarely read from, shallow types may actually
be faster.

\begin{table}[t]
  \caption{Worst-case costs for shallow and concrete types}
  \label{t:shallow-vs-concrete}

  \centering
  \(\begin{array}{lrrrr}
     & \mbox{Constructor} & \mbox{Cast} & \mbox{Read} & \mbox{Write} \\\hline
    \sptrawpydict                &           0 & O(1) & O(1) &     0 \\
    \sptchkdict{\sptype}{\sptype} &        O(N) & O(1) &    0 &  O(1)
  \end{array}\)
\end{table}



\subsection{Gradual Class Hierarchies}
\label{s:inheritance}

One important feature of \SP{} is that class hierarchies can
mix typed and untyped code.
An untyped class can inherit from a typed one and vice-versa,
letting programmers add types to a single class independently of its ancestors
and children.

% st-ecoop-2007 has no inheritance, object is collection of members simple (Abadi--Cardelli)

Gradual class hierarchies are rarely studied in the literature, especially
for a language where truly untyped classes can enter the mix.\footnote{Two
languages that provide separate hierarchies for untyped and (gradually) typed
classes are Thorn~\cite{wzlov-popl-2010} and SafeTS~\cite{rsfbv-popl-2015}.}
The closest related work, for Nom~\cite{mt-oopsla-2017}, implements
a rather flexible point in the design space.
\SP{} implements a simpler design that places a few restrictions on types and
inheritance:

\begin{enumerate}
  \item
    To benefit from types, classes must be declared on the module top level
    and may have at most one parent.
    Nested class declarations, first-class classes, and classes with
    multiple parents default to un-optimized Python behavior~(\cref{s:impl}).

  \item
    Methods cannot be overloaded.
    This restriction comes from Python.

  \item
    Methods and fields may be overridden in arbitrary ways by untyped code.
    In typed code, however, overrides must be compatible subtypes.
    For example, a method that returns a number cannot be overridden by a method
    that returns the dynamic type; \cref{f:gg-failure-stat} shows the static error
    that arises from such a static override.

    % In fact, \SP{} compiles fields using Python slots
    % declarations (\code{\_\_slots\_\_}).
    %
    % NOTE __ (dunder) methods may be overridden e.g. __getattribute__,
    % but the normal field access syntax skips any overrides (o.f)

\end{enumerate}
%
With this context in mind, \SP{} keeps track of whether each class is typed or untyped.
Each typed class can furthermore assume that if a method has a precise (non-dynamic)
type, then all typed overrides are subtypes of this type.
\SP{} can therefore optimize dispatch from typed callers to typed methods
and use checked dispatch for other combinations.
One extra step arises when an untyped class overrides a typed method.
In this case, \SP{} creates a wrapper around the overriding method to check
that it computes type-correct results.
% Because these wrappers perform a simple first-order check, they
% are supported by an efficiently implementation that cooperates with
% \SP{}
The wrappers are handled efficiently by a tailored implementation of vtables~(\cref{s:vtable}).


\subsection{Strict Modules}
\label{s:strict-mod}

%% 2022-01-12 Although the Static Python compiler can technically be
%% used apart from strict modules, and we do that in tests for faster tests, it’s
%% not sound and we don’t allow it in prod.

Python modules are mutable collections of names.
Names can be added, deleted, and updated at runtime.
\SP{} accommodates these behaviors in the same manner as standard Python, which
necessarily limits the benefits of module types.
As an alternative, \SP{} programmers may opt in to a \emph{strict module} semantics.
Strict modules are immutable, and thus enable type-based compiler optimizations.


\subsection{Progressive Primitive Types}
\label{s:c-types}

%% 2021-12-29: TODO
%% Using the term “ctypes” for these might be confusing, since the Python stdlib
%% has a “ctypes” module that isn’t related to our primitive types. We do call the
%% base type for them CType in our compiler, but when discussing them we usually
%% call them “primitive types” or “machine types” — “C types” could also work but
%% I wouldn’t combine it into one word :)

For performance-critical applications, \SP{} includes a set of primitive types
that describe booleans and sized numbers.
Example types include \code{int64}, \code{uint64}, \code{double}.
\SP{} also includes two special datatypes, \code{Array} and \code{Vector}, that store primitives.

The purpose of these types is to enable unboxed values and arithmetic at
runtime.
Consequently, their static semantics is a \emph{progressive}~\cite{pqk-onward-2012}
refinement over the semantics of basic Python types.
Primitive types cannot be implicitly cast to non-primitive types,
including the dynamic type---another violation of the static gradual guarantee.
Operations such as \code{and} (boolean conjunction) do not accept a mix of primitive and non-primitive data.
These restrictions give programmers a static separation between fast-running
primitives and standard data.

% Neither a module-level nor a closure-level variable may have a primitive
% type---because untyped code can mutate such variables.

% For now, programmers have to write and manage primitive types.
% In the future, a preprocessor might convert Python arithmetic to primitive arithmetic.

% https://github.com/facebookincubator/cinder/issues/52


\section{Runtime System Highlights}
\label{s:runtime}
%% alt title: Runtime System Highlights
%% Non-Highlights:
%% - shadow frames = JIT feature, lite array to track Python call stack

%% 2022-01-12
%% Cinder implements primitives with unboxed C values, which are much simpler and cheaper
%% than their Python counterparts.
%%
%% Cinder handles conversions at the boundaries between \SP{} code
%% and untyped code to avoid a cascade of modify-then-run refactorings, but nowhere else.
%% Within typed code, programmers must satisfy the type checker with
%% appropriate conversions.

The \SP{} runtime system, formally known as Cinder, extends
CPython 3.8 in several ways to take full advantage of static types.
Cinder includes tailored bytecode instructions, virtual method tables,
concrete datatypes, a registry of typed modules, and a JIT compiler.

These main ingredients of Cinder may be of interest to other teams seeking to
add sound gradual typing to an existing language.
For example, Node developers may wish to fork that runtime and experiment with
bytecode instructions that leverage sound static types.


\subsection{Bytecode Instructions}

Cinder is a bytecode compiler that extends the Python instruction set.
All the standard Python instructions work similarly to Python 3.8;
in other words, an untyped Python program has the same behavior in
Cinder as in the standard interpreter.
The added instructions help with one of three tasks:
expressing runtime checks,
initializing concrete-typed values,
or efficiently performing a standard action.
As an example of the third kind, the \code{FAST\_LEN} instruction quickly
computes the length of a built-in value.
\SP{} uses type information to decide where this instruction is appropriate
and applies it as an optimization.


\subsection{Virtual Method Tables}
\label{s:vtable}

Cinder adds virtual method tables (vtables) to typed classes.
These tables help to speed up method dispatch relative to Python's
dynamic lookup.
Calls to static methods that appear in statically-typed
code use the vtable to find an address for the method.
If the method is part of a final class, then the call is further optimized
to a direct function-call jump.
(Both vtable lookup and direct jumps are supported by Cinder-specific bytecode
instructions.)
Just-in-time compilation~(\cref{s:jit}) can also upgrade vtable lookups to
function calls.

The implementation of vtables happens to be built on the Python \code{vectorcall}
protocol; it is not a from-scratch development.
That being said, Cinder vtables are specialized to check untyped overrides
of typed methods against their expected return type (instead of using a layer of
indirection for the check).

%% beware: with vtables, method resolution is different than Python b/c args. get
%%   resolved before the receiver (A.m(B) goes "A->B" in Py. and "B->A" in SP)

%% > This difference in behavior isn’t so much desired as just a consequence of making
%% > `INVOKE_METHOD` optimizable. With a normal dynamic `CALL_FUNCTION`, first
%% > the callable is placed on the stack, then the arguments, then there is a
%% > `CALL_FUNCTION` (with number of args in oparg) to perform the call. This
%% > means that first the callable is resolved, then the arguments. But with
%% > `INVOKE_METHOD` we want to resolve the callable as part of the invoke
%% > itself, since this gives us opportunity to inline-cache the target of the
%% > call instead of always having to call something dynamic and unknown that’s
%% > on the stack. So that necessarily implies that first the arguments are
%% > resolved and placed on the stack, then the callable is resolved as part of
%% > the `INVOKE_METHOD`. -Carl


\subsection{Checked Data Structures}
\label{s:chkdict-impl}

The concrete versions of built-in data structures come with both a type and an
implementation.
The implementation provides the same interface as the built-in but uses a
type tag to reject certain operations.

For example, the type $\sptchkdict{K}{V}$ describes a concrete dictionary
with keys of type $K$ and values of type $V$.
The implementation has three main components:
\begin{itemize}
  \item
    First, the constructor uses a type and a Python dictionary ($\sptrawpydict$)
    to initialize a checked dictionary.
    This constructor ensures that all values of type $\sptchkdict{K}{V}$
    begin with well-typed elements.
  \item
    Second, all write operations check their input.
    Every operation that mutates or extends a checked dictionary must
    validate any untyped arguments that it receives.
  \item
    Third, the dictionary value stores a type tag to support casts from the dynamic type.
    When a checked dictionary enters typed code from an untyped context,
    the runtime checks its type tag to see whether the key and value types are an exact match.
    For example, type $\sptchkdict{K}{V}$ matches the type
    $\sptchkdict{\sptstr}{\sptdyn}$ only if $K$ is equal to $\sptstr$
    and $V$ is equal to $\sptdyn$,
\end{itemize}
%
In general, other checked datatypes have the same three components:
a constructor, checked update functions, and a tag.


\subsection{Classloader}
\label{s:classloader}

\SP{} keeps track of typed functions and typed classes with a specialized classloader.
At runtime, the classloader keeps a registry of typed objects and whether or not they
are mutable.
The registry helps the bytecode reference objects and types via their module names.
The mutability bit lets \SP{} optimize access for immutable data while soundly allowing
patches to mutable data.


\subsection{Method-at-a-Time JIT}
\label{s:jit}

Cinder includes a JIT (just-in-time) compiler for its bytecode.
At the moment, programmers enable the JIT by supplying a list of method names
to the compiler.
Any method can be JIT-compiled whether or not it uses \SP{} types,
though types are needed to enable the most-effective optimizations.

%% 2022-01-05 Carl:
%% "All the data I’ve been sharing is from a single codebase, the primary IG web
%% server monolith. The existence of JITted but not SP modules is mostly just due
%% to the fact that opting a function into the JIT is semantically transparent and
%% (unless it reveals a latent bug in the JIT) requires no code changes, so it’s
%% quite easy to do (the only tradeoff pushing us away from JITting everything is
%% just how much CPU we spend JIT-compiling and how much memory we spend storing
%% JIT-compiled code), whereas opting a module into SP requires more work so the
%% bottleneck is available developer time to do conversions."


\section{Model}
\label{s:model}

%% test suite is for counterex, not proof
%% 
%% (as opposed mech CONFUSSING let each sec explain purpose)
%% 
%% keep none None & explain why, ambiguity in stx
%% 
%% fully-sound weird, kill phrase ... say whats happening .... surface t is linter
%% ignore WF checker
%% 
%% check para may be red.
%% "The strict cast for checked dictionaries ...."
%% 
%% soundness, 1st para garbled don't need such a long reminder
%% 
%% Notable py **that we handle**
%% soundly => correctly
%% 
%% addl -> additionally (4.4)
%% 
%% "is triue" missing word
%% 
%% move 4.5 up to 4.1, start with the payoff --- found soundness bugs in a tool that's running in prod at instagram
%% 
%% rename 4.3 to "boundry type soundness" satate a lemma instead of full TS keep the focus, don't jump up
%% - make the proof case via Nom keep it short they have "detailed" proof
%% - "interested reader" can follow another direct path (edit current para2)
%% 
%% 4.0 put less emphasis on part2 of the soundness. ... it's not a threat its a boring swept-under-rug part ... maybe 4.5 is the new 4.0???
%% 
%% 4.4 redex = since no formalization of py + sp .. follow well-established path of using test suite to check conformance with **reality**
%% - cite Py \Js Jan paper, Politz getter-setter, Gardner js
%% 
%% 4.4 redex += everything in 4.1--4.3 is captured in redex, done 3 steps
%%  1 human verification, carefully spot-check python faithful, boundaries vs 4.1--4.3
%%  2 run againt SP tests .. indeed part of the reason for getting so much python is to run against an actual test suite
%%  3 b/c in redex, use pbt to verify conventional soundness
%% 
%% cut "soundness as baseline" final 2 sentences of 4.4(?) they're too weak, end with the compiler verification out-of-scope part



To validate the design of \SP{}, we have developed a model of the language in PLT
Redex~\cite{kcdeffmrtf-popl-2012}.
The model encompasses two soundness claims:
%% addresses two soundness concerns?
\begin{enumerate}
  \item
    \SP{}'s overall approach to gradual interactions is sound; in particular,
    interactions with untyped code do not undermine the validity of types.
  \item
    The typed half of \SP{} is a sound type system for Python.
\end{enumerate}
This section explores the first claim in depth by way of a small formalization
(as opposed to the Redex \emph{mechanization})
that illustrates the \SP{} gradual interaction strategy.
%% Compared to other gradual languages, these boundaries are quite restrictive---which
%% partly explains how it is able to perform well in practice~(\cref{s:eval}).
%% Indeed the boundaries are effectively a subset of those in Nom~\cite{mt-oopsla-2021}.
The second claim is justified by our Redex development and its test suite~(\cref{s:redex}).


\subsection{Surface Syntax and Types}

\begin{figure}[t]
  \begin{langarray}
    \spprog & \defeq &
      \spstmt \langmid \spstmt,~\spprog
  \\
    \spstmt & \defeq &
      \spvardef{\spx}{\sptype}{\spexpr} \langmid
  \\ & &
      \spfundef{\spf}{\spann{\spx}{\sptype}}{\sptype}{\spexpr} \langmid
  \\ & &
      \spclassdef{\spc}{\spc}{\spvardef{\spx}{\sptype}{\spexpr}}{\spfundef{\spf}{\spself, \spann{\spx}{\sptype}}{\sptype}{\spexpr}}
  \\
    \spexpr & \defeq &
      \spx \langmid \spnone \langmid \spint \langmid \spbool \langmid \spfloat \langmid \spobject \langmid
      \sppydict{\spx: \spexpr, \ldots} \langmid
      \spchkdict{\sptype}{\sptype}{\sppydict{\spx: \spexpr, \ldots}} \langmid
  \\ & &
      \spapp{\spx}{\spexpr} \langmid
      \spdictref{\spexpr}{\spexpr} \langmid
      \spdictset{\spexpr}{\spexpr}{\spexpr} \langmid
      \spobjref{\spc}{\spx} \langmid
      \spobjset{\spc}{\spx}{\spexpr} \langmid
      \spobjapp{\spc}{\spf}{\spexpr}
  \\
    \sptype & \defeq &
      \sptdyn \langmid
      \sptnone \langmid
      \sptint \langmid
      \sptbool \langmid
      \sptfloat \langmid
      \sptobject \langmid
      \sptclass \langmid
  \\ & &
      \sptpydict{\sptype}{\sptype} \langmid
      \sptchkdict{\sptype}{\sptype} \langmid
      \sptunion{\sptype, \ldots}
  \\
    \sptenv & \defeq &
      \sptenvnil \langmid
      \sptvardef{\spx}{\sptype},~\sptenv \langmid
      \sptfundef{\spf}{\sptype}{\sptype},~\sptenv \langmid
      \sptclassdef{\spc}{\spc}{\sptvardef{\spx}{\sptype}}{\sptfundef{\spf}{\sptclass, \sptype}{\sptype}},~\sptenv
  \\
    \spx, \spf & \defeq & \mbox{variable names}
  \end{langarray}

  \bigskip
  \mbox{Abbreviation: $\sptoptional{\sptype} \defeq \sptunion{\sptnone, \sptype}$}

  \caption{Surface Syntax and Types}
  \label{f:surface-types}
\end{figure}

\Cref{f:surface-types} illustrates key aspects of the \SP{} syntax and types.
A program is a sequence of statements;
a statement defines a variable, function, or class.
These definitions may only appear on the top level
and they all require full type annotations.
Functions must have one positional argument.
Classes must declare one parent (perhaps $\spobject$), one field, and one method.
Expressions describe values and simple computations.
The basic values consist of the following: the none value, integers,
booleans (which are the integers \code{0} and \code{1}), floating point numbers, and the top object.\footnote{By contrast to
Python, in which \code{int} is a type and \code{None} is a value, our formalization uses lowercase names for
values and capitalized names for types.}
There are two data structures: dictionaries and checked dictionaries~(\cref{s:checked-type}).
The remaining forms express function calls, dictionary reads and writes, object field reads and writes,
and method calls.
Types $\sptype$ include the dynamic type, types for the basic values, one type $\sptclass$ for every
user-defined class, and union types.
We assume that all unions are written in a tidy normal form, e.g., that
$\sptunion{\sptint, \sptunion{\sptdyn, \sptclass_0}}$ would be flattened and normalized to $\sptdyn$.
There is no function type in the model, or in \SP{} for that matter.
The only way to define a higher-order function is to use the dynamic type.

The surface types are meant to describe programs, but they are not designed
to be fully sound.
For this reason, we omit the surface typing judgment, which scans for
logical errors, and merely present the declarative syntax of surface types.
We also omit a well-formedness judgment that checks for circular definitions.

Relative to \SP{} and our Redex mechanization, the formalization in \cref{f:surface-types} omits
many details of Python including class variables, imports, conditionals, and exception handlers.
These details are crucial in the mechanization, which tests whether \SP{}
soundly approximates Python.
They are less important here, where our focus is on type boundaries.
None of the omitted features give substantially new ways for typed code to interact with dynamic code.


\subsection{Evaluation Types, Casts, and Typing Judgment}

\begin{figure}[t]
  \begin{langarray}
    \spteval & \defeq &
      \sptdyn \langmid
      \sptnone \langmid
      \sptint \langmid
      \sptbool \langmid
      \sptfloat \langmid
      \sptobject \langmid
      \sptclass \langmid
    \\ & &
      \sptrawpydict \langmid
      \sptchkdict{\spteval}{\spteval} \langmid
      \sptoptional{\spteval}
  \end{langarray}

  \bigskip
  \(
    \mftypeF{\sptype_0}
    \mfeq
    \left\{\begin{array}{ll}
      \sptrawpydict & \mbox{if $\sptype_0 = \sptpydict{\sptype}{\sptype}$}
    \\
      \sptoptional{\mftypeF{\sptype_1}} & \mbox{if $\sptype_0 = \sptoptional{\sptype_1}$}
    \\
      \sptdyn & \mbox{if $\sptype_0 = \sptunion{\sptype, \ldots}$ and $\sptype_0 \neq \sptoptional{\sptype}$}
    \\
      \sptchkdict{\mftypeF{\sptype_1}}{\mftypeF{\sptype_2}} & \mbox{if $\sptype_0 = \sptchkdict{\sptype_1}{\sptype_2}$}
    \\
      \sptype_0 & \mbox{otherwise}
    \end{array}\right.
  \)

  \caption{Evaluation Types, Surface-to-Evaluation Mapping}
  \label{f:surface-to-eval-types}
\end{figure}

Evaluation types $\spteval$ are a subset of the surface types.
These are the types that \SP{} promises to soundly enforce.
\Cref{f:surface-to-eval-types} presents the syntax of evaluation types
and a retraction $\mftypeF{\cdot}$ from surface types to evaluation types.
As the retraction shows, the evaluation types make two main changes:
\begin{enumerate}
  \item
    The parameterized type for Python dictionaries
    $\sptpydict{\sptype_0}{\sptype_1}$ gets replaced with
    a raw type $\sptrawpydict$.
    The raw type behaves the same as $\sptpydict{\sptdyn}{\sptdyn}$ would.
  \item
    Unions get replaced with the dynamic type, except for the special case
    of unions with none ($\sptoptional{\sptype_0}$).
\end{enumerate}


\subsubsection{Casts}

\SP{} evaluation types can all be enforced fully and in constant-time
with casts.
\Cref{t:cast} describes the casts in detail.
Most call for a tag check, i.e., a Python \code{isinstance} test.
The sole exception is optional types, which require a tag check and a test for the none value.
Even checked dictionaries rely on tag checks.
A checked dict type with keys $\spteval_0$ and values $\spteval_1$ accepts only
checked dict values that were initialized with exactly the same key and value type.
As noted in~\cref{s:type-dynamic}, the exact-match rules applies even when $\spteval_0$
or $\spteval_1$ is the dynamic type.

As promised, all casts run in constant time.
No cast requires traversing a data structure.
Similarly, no cast allocates a wrapper to check higher-order behaviors in a delayed fashion.
This latter property means that blame-tracking is trivial because
casts either succeed or fail immediately.
%% In other words, \SP{} provides \emph{immediate
%% accountability}~\cite{mt-oopsla-2017} for cast errors.

The strict cast for checked dictionaries greatly simplifies type compatibility for \SP{}.
Values that are partly-dynamic are simply incompatible with static types.
For example, suppose that a function expects a list of numbers.
In a typical gradual language, a list of dynamic values would be a valid input to the function.
In \SP{}, a list of dynamic values is not a valid input.
Consequently, \SP{} can use an ahead-of-time strategy to enforce soundness.
Any position where the dynamic type meets a static type needs a cast.
Other meetings between types can be resolved statically.
\SP{} does not need to worry that a list of dynamic values might be masquerading
under a fully-static type.

\begin{table}[t]
  \caption{How to Enforce the Evaluation Types}
  \label{t:cast}

  \(\begin{array}{l@{\quad}l}
    \mbox{Eval. Type $\spteval$} & \mbox{Description of run-time check} \\\hline
    \sptoptional{\spteval_0} & \mbox{Accepts either the none value or values that match $\spteval_0$} \\
    \sptrawpydict & \mbox{Accepts any Python dictionary} \\
    \sptchkdict{\spteval_0}{\spteval_1} & \mbox{Accepts checked dictionaries parameterized by $\spteval_0$ and $\spteval_1$} \\
    %% \sptchkdict{\spteval_0}{\spteval_1} & \mbox{Accepts checked dictionaries with the same key and value types (${\spteval_0, \spteval_1}$)} \\
    \sptdyn & \mbox{No check needed, accepts any value} \\
    \sptobject & \mbox{Accepts any value (except primitives,~\cref{s:c-types})} \\
    \sptclass_0 & \mbox{Accepts instances of class $\sptclass_0$} \\
    \sptnone & \mbox{Accepts the Python none value} \\
    \sptint & \mbox{Accepts integers} \\
    \sptbool & \mbox{Accepts booleans (the integers \code{0} and \code{1})} \\
    \sptfloat & \mbox{Accepts floats}
  \end{array}\)
\end{table}


\subsubsection{Expression Typing, Cast Insertion}

To better show where \SP{} needs to insert casts, we present a selection of typing rules.
Recall that a program declares variables, functions, and classes~(\cref{f:surface-types}).
These statements come with types and fill an environment ($\sptenv$).
Relative to the current environment, the expressions within each statement must
satisfy the typing judgment in~\cref{f:eval-types} 

The first two rules are for function application.
A typed function may be applied to an argument that matches its domain type,
in which case it computes a value that matches its codomain type.
A dynamically-typed variable may be applied to any input (that matches the top
type $\sptobject$) to yield a dynamically-typed result.
The next rules illustrate writes to Python dictionaries and checked dictionaries.
A shallow Python dict may be updated with any kind of key and value.
By contrast, a concrete checked dict requires keys and values that match its type parameters.
Next we have two rules for classes:
\trule{F-Set} says that writes to a class field must match the declared field
type; and \trule{M-App} shows that typed methods impose similar constraints as
typed fuctions.

The final two rules, \trule{C-Sub} and \trule{Matr}, depend on auxiliary judgments
for consistent subtyping ($\spcompat$) and materialization ($\spmatr$).
Consistent subtyping relates type $\spteval_0$ to type $\spteval_1$ if they are
related by static subtyping ($\spsubteq$) or if
$\spteval_1$ is the dynamic type.
When this relation holds, it is safe to upcast a value from type $\spteval_0$
to type $\spteval_1$.
Materialization relates the dynamic type to any non-dynamic type.
Occurrences of the \trule{Matr} rule are downcasts that require a
run-time check.

The name \emph{materialization} and the rule \trule{Matr} are inspired by prior
work~\cite{clps-popl-2019}.
By itself, the judgment is merely an upside-down type precision relation~\cite{g-icfp-2013,sv-dls-2008}.
Combined with the typing rule, however, materialization is a concise way to find
where a well-typed program needs casts to ensure soundness.
For example, suppose that $\spf$ is a function from integers to the dynamic
type and that $\spx$ is a variable with the dynamic type.
An application $\spapp{\spf}{\spx}$ can satisfy the type $\sptfloat$ using two materializations:

\medskip
\begin{mathpar}
  \inferrule*[left=Matr]{
    \inferrule*{
      \inferrule*[left=Matr]{
        \sptenv_0 \wtexpr \spx : \sptdyn
        \\
        \sptdyn \spmatr \sptint
      }{
        \sptenv_0 \wtexpr \spx : \sptint
      }
    }{
      \sptenv_0 \wtexpr \spapp{\spf}{\spx} : \sptdyn
    }
    \quad
    \sptdyn \spmatr \sptfloat
  }{
    \sptenv_0 \wtexpr \spapp{\spf}{\spx} : \sptfloat
  }

  \mbox{Where $\sptenv_0 = \sptvardef{\spx}{\sptdyn}, \sptfundef{\spf}{\sptint}{\sptdyn}$}
\end{mathpar}
\medskip
Consequently, this type derivation calls for two casts at run-time.

We end here, with materialization, rather than present a semantics
for the formalization.
After all, the main benefit of a full formal semantics is to validate
the behavior of complex expressions---and this job is
better left to the Redex mechanization.

Furthermore, our casts-via-materialization rule is more aggressive
than what \SP{} actually does to insert casts.
Because \SP{} supports interactions with unanalyzed Python modules, it inserts
casts in an overapproximate way:
\begin{itemize}
  \item
    typed functions and methods begin by checking all their arguments;
  \item
    typed classes check all field writes;
  \item
    checked dictionaries check all writes; and
  \item
    typed code checks the results of function calls, references, and other elimination forms
    whenever there is a materialization from the dynamic type.
\end{itemize}
\Cref{s:impl} explains
how the type-directed optimizer helps avoid some
of these checks.

\begin{figure}[p]
  \fbox{$\sptenv \wtexpr \spexpr : \spteval$}~selected rules
  \begin{mathpar}
    \inferrule*[left=S-App]{
      \sptfundef{\spf_0}{\spteval_0}{\spteval_1} \in \sptenv_0
      \\\\
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
    }{
      \sptenv_0 \wtexpr \spapp{\spf_0}{\spexpr_0} : \spteval_1
    }

    \inferrule*[left=D-App]{
      \sptvardef{\spf_0}{\sptdyn} \in \sptenv_0
      \\\\
      \sptenv_0 \wtexpr \spexpr_0 : \sptobject
    }{
      \sptenv_0 \wtexpr \spapp{\spf_0}{\spexpr_0} : \sptdyn
    }

    %% TODO show dict read rules?
%    \inferrule*[left=PD-Ref]{
%      \sptenv_0 \wtexpr \spexpr_0 : \sptrawpydict
%      \\\\
%      \sptenv_0 \wtexpr \spexpr_1 : \sptobject
%    }{
%      \sptenv_0 \wtexpr \spdictref{\spexpr_0}{\spexpr_1} : \sptdyn
%    }
%
%    \inferrule*[left=CD-Ref]{
%      \sptenv_0 \wtexpr \spexpr_0 : \sptchkdict{\spteval_0}{\spteval_1}
%      \\\\
%      \sptenv_0 \wtexpr \spexpr_1 : \spteval_0
%    }{
%      \sptenv_0 \wtexpr \spdictref{\spexpr_0}{\spexpr_1} : \spteval_1
%    }

    \inferrule*[lab=PD-Set]{
      \sptenv_0 \wtexpr \spexpr_0 : \sptrawpydict
      \\\\
      \sptenv_0 \wtexpr \spexpr_1 : \sptobject
      \\\\
      \sptenv_0 \wtexpr \spexpr_2 : \sptobject
    }{
      \sptenv_0 \wtexpr \spdictset{\spexpr_0}{\spexpr_1}{\spexpr_2} : \sptnone
    }

    \inferrule*[lab=CD-Set]{
      \sptenv_0 \wtexpr \spexpr_0 : \sptchkdict{\spteval_0}{\spteval_1}
      \\\\
      \sptenv_0 \wtexpr \spexpr_1 : \spteval_0
      \\\\
      \sptenv_0 \wtexpr \spexpr_2 : \spteval_1
    }{
      \sptenv_0 \wtexpr \spdictset{\spexpr_0}{\spexpr_1}{\spexpr_2} : \sptnone
    }

    %\inferrule*[left=F-Ref]{
    %  \spann{\spx_0}{\spteval_0} \in \spenvapp{\sptenv_0}{\spc_0}
    %}{
    %  \sptenv_0 \wtexpr \spobjref{\spc_0}{\spx_0} : \spteval_0
    %}

    \inferrule*[left=F-Set]{
      \spann{\spx_0}{\spteval_0} \in \spenvapp{\sptenv_0}{\spc_0}
      \\\\
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
    }{
      \sptenv_0 \wtexpr \spobjset{\spc_0}{\spx_0}{\spexpr_0} : \sptnone
    }

    \inferrule*[left=M-App]{
      \sptfundef{\spf_0}{\spc_0, \spteval_0}{\spteval_1} \in \spenvapp{\sptenv_0}{\spc_0}
      \\\\
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
    }{
      \sptenv_0 \wtexpr \spobjapp{\spc_0}{\spf_0}{\spexpr_0} : \spteval_1
    }

    \inferrule*[left=C-Sub]{
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_1
      \\\\
      \sptenv_0 \wtsub \spteval_1 \spcompat \spteval_0
    }{
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
    }

    \inferrule*[left=Matr]{
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_1
      \\\\
      \spteval_1 \spmatr \spteval_0
      %% side condition: result type is not a primitive
    }{
      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
    }

  \end{mathpar}

  \begin{minipage}[t]{0.6\columnwidth}
    \fbox{$\sptenv \wtsub \spteval \spcompat \spteval$}
    \begin{mathpar}
      \inferrule*{
        \sptenv_0 \wtsub \spteval_0 \spsubt \spteval_1
      }{
        \sptenv_0 \wtsub \spteval_0 \spcompat \spteval_1
      }

      \inferrule*{
      }{
        \sptenv_0 \wtsub \spteval_0 \spcompat \sptdyn
      }
  \end{mathpar}

  \end{minipage}\begin{minipage}[t]{0.4\columnwidth}
    \fbox{$\spteval \spmatr \spteval$}
    \begin{mathpar}
      \inferrule*[right={$\spteval_0 \neq \sptdyn$}]{
      }{
        \sptdyn \spmatr \spteval_0
      }
    \end{mathpar}
  \end{minipage}

  \medskip
  \fbox{$\sptenv \wtsub \spteval \spsubteq \spteval$}~reflexive, transitive closure of the following $\spsubt$ relation:
  \begin{mathpar}
    \inferrule*{
    }{
      \sptenv_0 \wtsub \spteval_0 \spsubt \sptobject
    }

    \inferrule*{
    }{
      \sptenv_0 \wtsub \sptbool \spsubt \sptint
    }

    \inferrule*{
      \sptenv_0 \wtsub \spteval_0 \spsubt \spteval_1
    }{
      \sptenv_0 \wtsub \spteval_0 \spsubt \sptoptional{\spteval_1}
    }

    \inferrule*{
      \sptclassdef{\sptclass_0}{\sptclass_2}{\ldots}{\ldots} \in \sptenv_0
      \\
      \sptenv_0 \wtsub \sptclass_2 \spsubt \sptclass_1
    }{
      \sptenv_0 \wtsub \sptclass_0 \spsubt \sptclass_1
    }

%    \inferrule*{
%    }{
%      \spteval_0 \spsubt \spteval_0
%    }
%
%    \inferrule*{
%      \spteval_0 \spsubt \spteval_1
%      \\
%      \spteval_1 \spsubt \spteval_2
%    }{
%      \spteval_0 \spsubt \spteval_2
%    }
  \end{mathpar}

  \caption{Expression Typing, Consistent Subtyping, and Materialization}
  \label{f:eval-types}
\end{figure}


%\subsubsection{Program Typing, Inheritance Restriction}
%
%\Cref{f:program-typing} presents the typing judgment for programs,
%which folds over a sequence of statements to build a type environment.
%The typing rules for variables and functions are standard.
%We draw attention to the rule for classes, in particular the override condition.
%A class may override fields and methods from its parent;
%if it does, the overriding definition must be a \emph{static subtype} of the original.
%For example, a method that returns an integer can be overridden by a method that returns
%a boolean, but it cannot be overriden by a method that returns the dynamic type.
%This restriction lets the \SP{} compiler avoid some run-time checks; it can assume
%that static methods return reliable values instead of having to insert checks for subtypes.
%
%\begin{figure}[t]
%  \fbox{$\sptenv \wtprog \spprog \dashv \sptenv$}
%  \begin{mathpar}
%    \inferrule*{
%      \sptenv_0 \wtprog \spstmt_0 \dashv \sptenv_1
%      \\\\
%      \sptenv_1 \wtprog \spprog_0 \dashv \sptenv_2
%    }{
%      \sptenv_0 \wtprog \spstmt_0, \spprog_0 \dashv \sptenv_2
%    }
%
%    \inferrule*{
%      \sptenv_0 \wtexpr \spexpr_0 : \spteval_0
%    }{
%      \sptenv_0 \wtprog \spvardef{\spx_0}{\spteval_0}{\spexpr_0} \dashv \sptvardef{\spx_0}{\spteval_0},~\sptenv_0
%    }
%
%    \inferrule*{
%      \sptenv_1 = \sptfundef{\spf_0}{\spteval_0}{\spteval_1},~\sptenv_0
%      \\\\
%      \sptenv_1 \wtexpr \spexpr_0 : \spteval_1
%    }{
%      \sptenv_0 \wtprog \spfundef{\spf_0}{\spann{\spx_0}{\spteval_0}}{\spteval_1}{\spexpr_0} \dashv \sptenv_1
%    }
%
%    \inferrule*{
%      \sptenv_1 = \sptclassdef{\spc_0}{\spc_1}{\sptvardef{\spx_0}{\spteval_0}}{\sptfundef{\spf_1}{\spc_0, \spteval_1}{\spteval_2}}, \sptenv_0
%      \\\\
%      %% TODO are field overrides exact?
%      \mbox{if $\spann{\spx_0}{\spteval_0'} \in \spenvapp{\sptenv_1}{\spc_1}$ then $\spteval_0 = \spteval_0'$}
%      \\\\
%      %% TODO can T override dyn?
%      \mbox{if $\sptfundef{\spf_1}{\spc_2, \spteval_1'}{\spteval_2'} \in \spenvapp{\sptenv_1}{\spc_1}$ then $\spteval_1' \spsubteq \spteval_1$ and $\spteval_2 \spsubteq \spteval_2'$}
%      \\\\
%      \sptenv_1 \wtexpr \spvardef{\spexpr_0} : \spteval_0
%      \\
%      \spann{\spself}{\spc_0}, \spann{\spx_1}{\spteval_1}, \sptenv_1 \wtexpr \spexpr_1 : \spteval_2
%    }{
%      \sptenv_0 \wtprog \spclassdef{\spc_0}{\spc_1}{\spvardef{\spx_0}{\spteval_0}{\spexpr_0}}{\spfundef{\spf_1}{\spself, \spann{\spx_1}{\spteval_1}}{\spteval_2}{\spexpr_1}} \dashv \sptenv_1
%    }
%  \end{mathpar}
%
%  \caption{Program Typing}
%  \label{f:program-typing}
%\end{figure}


\subsection{Type Soundness}

The central question for the model is whether \SP{}'s approach to gradual typing
is sound.
No matter how an expression mixes typed and untyped code, its static
\emph{evaluation type} should be an accurate prediction about the results
of evaluation.
Using the metavariable $\spvalue$ to represent heap-allocated Python values
and $\sprred$ as the evaluation relation (which would need to maintain a heap),
an approximate soundness theorem is as follows:

\begin{theorem}[Type Soundness]
  If\ \(~\vdash \spexpr : \sptype\)
  then one of the following holds:
  \begin{itemize}
    \item
      \(\spexpr \sprred \spvalue
        \mbox{ and }
        \vdash \spvalue : \mftypeF{\sptype}
      \)
    \item
      \(\spexpr\) reduces to an allowed error
    \item
      \(\spexpr\) diverges
  \end{itemize}
\end{theorem}

As mentioned above, our argument for soundness has two parts
The question at hand is whether the boundaries to type dynamic
are adequately protected with run-time checks.
The Redex mechanization's comprehensive test suite provides the other half of the
argument; namely, that \SP{} is a sound type system for Python.

The direct path to boundary soundness involves two observations.
First, every evaluation type can be enforced with a decidable cast.
This is clearly the case for basic values such as floats.
It true for parameterized types such as $\sptchkdict{\spteval_0}{\spteval_1}$
because of their strict semantics.
Second, all boundaries relate the dynamic type to an evaluation type.
There are no significant boundaries that relate a partially static type
to an evaluation type.
This is due to the strict semantics for checked types and the fact that
$\sptoptional{\sptdyn}$ normalizes to the dynamic type.

Alternatively, observe that the boundaries in \SP{} are a subset
of the possible boundaries in Nom, a gradual language that comes with a detailed
proof of soundness~\cite{mt-oopsla-2017,mt-oopsla-2021}.
Given an \SP{} program, we can derive a Nom program with
the same type boundaries by replacing every checked dict instance
with a fresh class type.
Because distinct checked dict instantiations are incompatible,
the \SP{} boundaries impose the same constraints as the translated Nom
boundaries.


\subsection{Redex Development, \SP{} Conformance}
\label{s:redex}
%% pbt for soundness?

By contrast to the small formalization presented in this section,
our Redex mechanization covers both type boundaries and a large subset of Python.
Notable Python features include module imports, loops, exception handlers, and
delete statements (for class members and attributes).
To ensure that these features are implemented correctly and soundly, the
model includes hundreds of test programs adapted from the \SP{} test suite.\footnote{
  Most of the 214 tests are direct translations of \SP{} conformance tests to
  the syntax of the model.
  A program that implements the translation is included with our Redex development.
  The other 52 tests are not directly expressible in the model; for these, we
  translated salient aspects of each test by hand.}
These tests exercise a variety of Python behaviors, thereby giving us confidence
that the model is sound for Python.
Some tests intentionally raise type errors, some raise exceptions, and the rest
compute a specific result; \SP{} agrees on these end-to-end behaviors.
We have additional applied Redex's random testing tools~\cite{kf-sfp-2009}
to validate soundness.
%% FILL how many random tests?
%% FILL what bugs did random catch?

The model intentionally does not cover all of Python.
Some aspects of \SP{} are left out because they are straightforward to
handle soundly.
These include primitive types~\cref{s:c-types} and strict modules~\cref{s:strict-mod}.
Aspects of \SP{} that do not pertain to soundness, such as the quality of error messages,
are also omitted.
Other Python features are left out either because their \SP{} semantics is identical
to the baseline Python semantics or because they would entail a separate project~(\cref{s:impl}).
In particular, modelling type-directed optimization would require substantial
components: a model of the \SP{} bytecode and a faithful rendering of its
transformations.
Our model establishes soundness as a baseline.
Future work can use soundness as a starting point for compiler verification,
or informally leverage soundness to reason about possible optimizations.


\subsection{The Payoff: Issues Reported}

While modelling \SP{}, we found several issues with the language
and submitted them as bug reports to the \SP{} developers.
Overall, we reported 25 issues~(listed in \cref{a:github-issues}).
Four of these were critical soundness issues, one of which resulted in
a segmentation fault.
All but one of these soundness issue have been fixed.
Five issues were relatively minor; these dealt with confusing error messages
and incorrect tests.
The remaining 16 issues report bugs in language design and implementation.
The \SP{} team has acknowledged these bugs as such by applying a specific GitHub label (\code{sp-correctness}).

For example, we discovered that \SP{} handled the following function incorrectly when
we tried to model it:
%% \url{https://github.com/facebookincubator/cinder/issues/62}

\medskip
\begin{minipage}[t]{0.25\columnwidth}~
\end{minipage}\begin{minipage}[t]{0.4\columnwidth}
\begin{lstlisting}
  from typing import Optional

  def f(x: Optional[str]) -> str:
    while True:
      if x is None:
        break
      return x

  print(f(None))
  # None
\end{lstlisting}
\end{minipage}

\noindent{}The function expects either a string or the \code{None} value and promises to return a string.
When called with \code{None}, however, the function breaks out of the \code{while} loop
and implicitly returns \code{None}---disobeying the return type.
\SP{} had failed to account for the \code{break} and implicit return.
More concerningly, the associated test case \emph{expected} the program to type check.
Creating a formal model helped us catch this specification error.

% In addition to these formal issue reports,
% we had several long discussions together (between Brown and Instagram)
% about finer points in the language design.



\section{Scaling to Python}
\label{s:impl}

%% TODO SP side channels:
%% ?? eval,
%% the locals and globals dicts (the latter can be accessed through frame objects at the moment),
%% and mutable closure cells.

This section explains significant aspects of \SP{} that lie outside the
scope of our model.
These include sound interactions with Python code,
the bytecode language and optimizations, and dynamic Python features
that \SP{} does not type.


\subsection{Interactions with Open-World Python Code}

Although \SP{} is technically a new language, it is designed for gradual adoption.
Python programmers should be able to add types module-by-module to an
existing codebase.
Consequently, \SP{} supports interactions with Python modules in the only viable
way: by letting the Python code run with zero static constraints and minimal
dynamic constraints.

There are two case in which \SP{} types impose constraints on untyped Python code.
First, concrete generic types (e.g. $\sptchkdict{\sptype}{\sptype}$)
reject inputs that were not created via a checked contructor.
If a client of a Python module decides to impose concrete types, the Python module
may need to change.
Second, the strict setting for modules prevents updates to module-level variables.
If existing code mutates a binding in a strict module, a run-time error will
occur.

Interactions with \emph{open-world}~\cite{vss-popl-2017} Python code pose a minor
threat to soundness because
typed functions (and methods) cannot assume that their arguments are
well-typed.
All arguments sent from typed contexts get validated either statically or
via materialization casts, but arguments from untyped contexts are unchecked.
For this reason, \SP{} compiles every typed function to check its inputs.
Similarly, concrete types such as $\sptchkdict{\sptype}{\sptype}$ also
check their writes.
%% 2022-01-09 worth mentioning primitive types? they get cast like anything else (they don't materiazize)
%% 2022-01-13 don't think so --- leave prims alone, we don't want to frighten reviews with unsoundness


\subsection{Bytecode and Optimizations}
\label{s:optimize}

\SP{} can generate efficient code because it targets
the Cinder runtime.
Cinder extends the Python 3.8 bytecode with instructions to check types at run-time,
to construct \SP{} data structures, and to perform actions in a way that benefits from
static information..

\begin{table}
  \caption{Representative Cinder bytecode instructions}
  \label{t:bytecode}

  \begin{tabular}{lll}
    {Instruction} & {Purpose} & {Description} \\\hline
    \bcinst{CAST} & Soundness & Assert that a value matches a type \\
    \bcinst{CHECK\_ARGS} & Soundness & Cast all inputs to a function \\[1ex]

    \bcinst{BUILD\_CHECKED\_MAP} & Constructor & Make a checked dictionary \\
    %\bcinst{BUILD\_CHECKED\_LIST} & Constructor & Make a checked list \\
    \bcinst{TP\_ALLOC} & Constructor & Make a \SP{} object \\[1ex]

    \bcinst{INVOKE\_FUNCTION} & Optimization & Execute a direct function call \\
    \bcinst{INVOKE\_METHOD} & Optimization & Execute a method via the object's vtable \\
    \bcinst{LOAD\_FIELD} & Optimization & Read an object field \\
    \bcinst{STORE\_FIELD} & Optimization & Write to an object field \\
    \bcinst{FAST\_LEN} & Optimization & Get length of a built-in value \\
    \bcinst{REFINE\_TYPE} & Optimization & Type declaration for the JIT \\

%%% Other bytecodes ... either from Carl's talk or the SP repo
%CONVERT_PRIMITIVE
%INT_LOAD_CONST_OLD
%JUMP_IF_NONZERO_OR_POP
%JUMP_IF_ZERO_OR_POP
%LIST_DEL
%LOAD_ITERABLE_ARG
%LOAD_LOCAL
%LOAD_MAPPING_ARG
%POP_JUMP_IF_NONZERO
%POP_JUMP_IF_ZERO
%PRIMITIVE_BINARY_OP
%PRIMITIVE_BOX
%PRIMITIVE_COMPARE_OP
%PRIMITIVE_LOAD_CONST
%PRIMITIVE_UNARY_OP
%PRIMITIVE_UNBOX
%RETURN_PRIMITIVE
%SEQUENCE_GET
%SEQUENCE_REPEAT
%SEQUENCE_SET
%STORE_LOCAL

  \end{tabular}
\end{table}

\Cref{t:bytecode} lists a few representative bytecode instructions.
The two instructions that express run-time checks are \code{CAST}
and \code{CHECK\_ARGS}.
The former checks a value against a type.
The latter is for functions and methods; it checks all inputs to a function
against their declared types.

Two of the listed instructions allocate \SP{}-specific data structures.
The first creates a checked dictionary; the second creates an object with a vtable~(\cref{s:vtable}).
Cinder comes with a similar instruction to build checked lists.
%% The developers will add more instructions along the same lines in the future.

The remaining instructions are for optimization.
Both \bcinst{INVOKE\_FUNCTION} and \bcinst{INVOKE\_METHOD} are alternatives
to Python's dynamic call dispatch.
The former jumps to a statically-determined address;
the latter uses a vtable lookup to quickly find an address at run-time.
The load and store instructions for fields improve upon Python's generic attribute lookup.
In the JIT, these instructions can sometimes be further optimized to a single assembly instruction.
The \bcinst{FAST\_LEN} instruction gets the length of a built-in datatype directly, instead
of using the Python \code{\_\_len\_\_} attribute.
Lastly, the \bcinst{REFINE\_TYPE} instruction tells the JIT about the type of a local value whose
type is not clear from the context.


\paragraph{Indirect Optimization}

In addition to upgrading bytecode instructions to optimized ones, \SP{} takes care
to minimize the type checks that it executes at run-time.
In other words, the goal is to slow code down as little as possible.

Part of this goal is met by inserting casts only in positions where the dynamic
type flows into a static type.
The materialize rule in the model illustrates this policy.
Typed functions, however, are compiled with a \bcinst{CHECK\_ARGS} instruction
that defensively casts all arguments.
By convention, this instruction always appears on the first line of a typed
function body.
The optimizer uses this convention to skip argument checks by jumping past them
when it is safe to do so; namely, whenever a typed function or method gets
called in a typed context.


\subsection{Dynamic Python Features}
\label{s:dynamic-python}

%% TODO 2022-01-09 be careful here ... the model may indeed handle module vars
%%  the thing is, they're untyped and (maybe) not tested

\SP{} does not ascribe types to the following Python features.
These are not covered in our model because the implementation simply
assigns the dynamic type and lets the runtime treat them as untyped
Python code.
For each, the dynamic type is a very reasonable choice;
accurate static types would be burdensome to maintain.


\paragraph{First-Class Classes}

\SP{} does not attempt to type first-class classes: partly because they have
yet to appear in performance-critical code in the Instagram web server
and partly because they do not fit well with a nominal type system.
The straightforward but restrictive approach for first-class nominal class types
is to force code that uses a first-class class to expect subtypes of a
particular named static class.
Flatt et al.~\cite{fkf-popl-1998} propose a more-flexible approach, %(specifically for mixins)
but it requires a second layer of \emph{interface types} atop the nominal hierarchy.
MonNom~\cite{mt-oopsla-2021} uses interfaces in a similar way to accommodate
structural objects.
How best to add an interface layer in \SP{} is an open question.

% in particular , Python's multiple inheritance would complicate the mixin story.
% Classic mixins rely on structural types~\cite{bc-oopsla-1990}.

%Notes on first-class classes being untyped:
%- mixin-based code tends to structrural types
%- nominality overly restrictive, get forced into <: hierarchy
%- but don't have NO IDEA for wat to do
%  + classes and mixins paper shows one idea,
%    ... need complicated mixin study??? (many sub objects)
%    built new type system to be mixin-aware, layered atop java
%    unsure if such extension works for SP
%    furthermore, class-and-mixins depends on Java single inheritance
%  + bracha cook mixin pattern
%  + tate muehlboeck structural object + interfaces


\paragraph{Multiple Inheritance}

%% https://docs.python.org/3/reference/datamodel.html
%% TODO check Dino email, confirm with C&D that layout conflict is unrelated to vtables

Python allows classes to inherit from a list of parents.
To resolve method calls to such a class, Python
dynamically traverses the parent list in a fixed order
seeking a first match.

Due to the dynamic method resolution order (MRO),
\SP{} does not track types for classes with multiple parents.
Method calls to these classes execute the same way as
in Python, with no type-directed optimizations to improve dispatch.


\paragraph{Dynamic Execution}

%% 2022-01-13: __setattr__ is along the same lines
%%Carl: Removing the use of super-dynamic Python features like
%%\code{\_\_setattr\_\_} that we don’t support. So far in the cases where
%%we’ve done this it hasn’t required a major rewrite.

Results computed by calls to \code{eval} and \code{exec}
have the dynamic type.
Their inputs run without being rewritten by the optimizer.

Studies of JavaScript and R have shown that many uses of dynamic execution
can be removed through simple adjustments~\cite{rhbv-ecoop-2011,gdkkv-oopsla-2021,mrmv-esop-2012}.
Assuming these findings carry over to Python, similar adjustments would
preferable over attempting to type eval.



%% 2022-01-13 covered pretty well earlier
%%\paragraph{Module-Level Variables}
%%
%%Any Python module can read and write to the module-level variables of another module.
%%When compiling a module, \SP{} therefore assumes that its module-level variables
%%may be modified by untyped code and assigns the dynamic type.
%%
%%Strict modules as an alternative to the Python
%%semantics.\footnote{https://instagram-engineering.com/python-at-scale-strict-modules-c0bb9245c834}
%%If a programmer chooses to declare a module as strict, then its module-level varibles
%%are immutable and thus typeable.
%%
%%Another potential solution is for the Cinder runtime to check that writes to module-level variables
%%preserve their types.
%%There are two downsides to this idea:
%%it will add some performance overhead,
%%and it will force developers to rewrite untyped code in order to fix any errors that arise.
%%%% Because of the latter concern, type dynamic is a very reasonable default.



\section{Production Experience}
\label{s:eval}

%% 2022-01-14 TODO re 3.7%
%% That percentage represents the aggregate CPU improvement observed from all of
%% our individual diffs that converted modules to Static Python over the past
%% year. In a sizable number of cases a conversion to Static Python did mean that
%% functions in that module started being JITted that previously were not JITted,
%% because for most of the half we had a policy in place that all Static Python
%% modules are always JITted. (We’ve now decoupled these things for future
%% conversions, so opting functions into the JIT is now orthogonal to opting them
%% into SP.)
%% 
%% So the 3.7% does not include any CPU wins that Cinder or the JIT provide in any
%% non-static modules, it only includes improvements observed from specifically
%% converting a module from nonstatic to static. But it does in some cases include
%% the effects of going from nonstatic + no-JIT to SP+JIT for a given module. In
%% other cases a conversion may have gone from nonstatic+JIT to SP+JIT.
%% Unfortunately we don’t have any way to go back and tease apart these cases for
%% each individual module conversion.
%% 
%% What we are doing now is an experiment where we turn off SP in a set of hosts
%% and observe them relative to the rest of prod, without changing the JIT list.
%% This will show some % regression, which we expect to be some number <3.7%, and
%% that will give a solid figure for the benefit we are getting specifically from
%% SP across all static modules, totally independent of the JIT. Unfortunately
%% there have been some hiccups in this experiment and we don’t have that number
%% ready yet, but we hope to have it in the next week or so.

%% 2022-01-14 FILL TODO 
%% > I still have trouble understanding the CPU number. There must be many
%% > servers running many workloads and some statistics to merge them. Do
%% > you have a blog post or something that explains the profiling in more
%% > detail?
%% 
%% I don’t know of anything reasonably current in terms of blog posts. For IG web
%% prod, there are not “many workloads” — there is no specialization in the IG web
%% tier. There are many thousands of hosts, all running the exact same workload —
%% all those hosts are handling an undifferentiated random selection from a single
%% giant pool of incoming IG requests. So for all intents and purposes we can
%% consider them identical. (There are in practice some differences in the hosts
%% themselves — e.g. different generations of CPU hardware — that we do have to
%% take into account when running the experiments below.)
%% 
%% The details of how we measure a CPU regression or improvement are interesting,
%% though. What we do is we take a set of hosts that we want to measure (typically
%% an experiment group and a control group, where the control group is identical
%% to the rest of production and the experiment group has some change made to its
%% code or configuration whose effect we want to measure), and we slowly increase
%% the traffic to those hosts until they are at max CPU utilization — they cannot
%% handle any more traffic without falling over. Then we measure the
%% requests-per-second handled by each set of hosts; if the experiment group is
%% able to handle 2% more requests per second than the control group, while both
%% are at max CPU utilization, this effect is considered a 2% global CPU win.
%% 
%% This metric has the advantage that it is highly holistic and results-oriented;
%% it is a measure of our actual capacity to serve more requests with fewer hosts,
%% and thus it can subsume and account for, and give apples-to-apples comparison
%% of, many different possible reasons for an increase or decrease in a host’s
%% efficiency in serving requests.
%% 
%% The disadvantage of the metric is that the raw number it measures (requests per
%% second) is also highly dependent on the product code and client behavior at
%% that moment in time, and is not stable over time, because the average cost in
%% CPU cycles of “one request” is not stable over time. If the behavior of the IG
%% iOS or Android app changes so that it is sending more heavy requests and fewer
%% lightweight requests, RPS across the fleet will naturally decrease even though
%% the efficiency of the servers has not changed. Therefore, this metric is really
%% good for saying “at X point in time, Y change has a Z% overall effect on our
%% CPU efficiency” but it cannot be used to compare raw numbers from two different
%% points in time; we cannot use it to say “between X1 point in time and X2 point
%% in time, RPS increased Z%, therefore our efficiency has increased by Z%.”
%% 
%% So the 3.7% number we gave you is an aggregate win from doing many such
%% individual experiments over the course of the past year, where each experiment
%% was measuring the effect of converting X module (or small set of modules) from
%% nonstatic to static (where in some cases it was nonstatic+JIT to SP+JIT, and in
%% other cases it was nonstatic noJIT to SP+JIT.) And the updated number we hope
%% to get you soon is an overall measure from a single experiment, today, of the
%% effect of disabling SP everywhere, while leaving the JIT list untouched. We
%% expect the latter number to be smaller than 3.7% because it will remove the JIT
%% factor entirely, but there’s also an unknown factor (which could net positive
%% or negative) of how the behavior of long-ago-converted SP modules has changed,
%% or the capabilities of SP has changed, since their conversion, which changes
%% the net win of SP on those modules since the time when we converted them.

%% 2022-01-04 TODO have no evidence that "any module" typing works out ... team
%% tried hard to get network effects ... "We explicitly aimed for converting
%% related modules like this to improve network effects and get better
%% performance."

%% TODO 2021-12-29 Carl
%% We definitely did find some regressions (especially when converting Cython, but
%% also one or two in non-Cython conversions.) But we were never satisfied with a
%% regression, and we were always able to apply the JIT or improve SP
%% optimizations or adjust the code to turn the regression neutral or positive.
%% (In fact I think all? the non-Cython regressions I can recall boiled down to
%% “we forgot to enable the JIT for an important function” and just rectifying
%% that took care of it.)

The Instagram web server has been running \SP{} in production since April 2021.
Overall, the results are very encouraging.
Instagram's internal profiling tools, which continuously monitor
performance, attribute a \CPUchange{} improvement in global CPU to \SP{} conversions.
\Cref{t:prod-stat} reports a few other production statistics.
Over 500 modules have been converted thus far.
Despite some initial regressions, none of the converted modules
ran slower after small rewrites and enabling the JIT on certain functions.

\begin{table}
  \caption{Overview: \SP{} in production}
  \label{t:prod-stat}
  \begin{tabular}{l@{~~}l@{\qquad}l@{~~}l}
    %% 541 modules out of ~45000 total
    8     & months in production   & 541   & typed, strict modules \\
    \CPUchange{} & global CPU improvement &   9   & using concrete types \\
    0     & net regressions        &  12   & using primitive types \\
    %% all prims are int32 and int64 and cbool
    %% 873 modules use JIT for some functions (about to increase by OOM)
  \end{tabular}
\end{table}


\subsection{Migration Path}

\SP{} first entered the web server codebase as a replacement for a
few critical Cython modules.
Cython had improved performance by compiling these modules to C,
but its partial adoption had led to an awkward workflow (with a
few compiled modules spread across an interpreted codebase).
Replacing these modules with \SP{} let programmers return to a conventional
Python workflow.
Furthermore, \SP{} types combined with Cinder resulted in a
0.7\% reduction in global CPU usage.
Primitive types~(\cref{s:c-types}) were essential for matching Cython.

Later \SP{} migrations have been directed by profiling to find frequently-executed code.
During the first half of 2021, the \SP{} team identified critical
modules and proposed types plus small code changes to the maintainers of these modules.
The accepted proposals resulted in a 1\% improvement in global CPU usage.
During the second half of 2021, the \SP{} team applied the same
process at a larger scale.
They also modified a code-generating module to output \SP{} code;
this one change brought over four hundred generated modules into the typed fold.
Overall, the second-half changes added a 2\% global CPU improvement.

As of December 2021, the \SP{} team has converted 541 modules.
Most of these came from the code-generating tool (417); the rest
are from hand conversions (124).
These modules are well-mixed with untyped modules in the codebase.
According to an analysis of identifiers that cross module-dependence
boundaries, over 30,000 identifiers go between typed and untyped code.
Two-thirds of these crossings are exports from \SP{} modules
to untyped modules; in other words, typed identifiers are widely used
throughout the web server.
%% data in src/static-python-imports-analysis
%% TODO gotta compare to TR etc.

% In a typical week, the team adds types to four additional modules.
% These modules have seen speedups ranging from 0\% to 25\% depending
% on their nature.
% Regressions have not been an issue.
% The only cause for alarm is when a module gets only a small improvement
% without code changes.


\subsection{Analyzing Code Changes}

Because the \SP{} team has been changing code as well as types during its
migrations, the question arises as to whether the code changes raise any
threats to validity.
It could be that the \SP{} approach to gradual typing only pays off
after significant modifications.
%% Carl: "I reviewed the ~30 conversion diffs"
We therefore reviewed the $\sim 30$ conversion diffs that significantly improved
performance.

In general, the patches have minor code changes and most of these changes
affect tests rather than production code.
Digging deeper, there are nine common kinds of changes: six address
type errors and the other three are for performance.

%% one significant change: replaced `contextlib.ContextDecorator` with `__static__.ContextDecorator`
%%  removes an extra call layer
%%  helps with (timing [ context managers / decorators ])

\subsubsection{Code Changes for the Type Checker}

    %% X bg: lookup the dino email about mocks
    %% And we do go through great lengths to make monkey patching work.  Because
    %% we need to enforce return types it ends up being not quite as flexible as
    %% normal Python.  For example one common pattern is to use Python’s mock
    %% library and we currently end up throwing lots of TypeError’s when a
    %% function which returns None is mocked and starts returning a MagicMock
    %% object instead.  But it’s an easy fix in that you can specify the return
    %% value to be compatible.  There may be more complex cases where you want to
    %% return a mock for an actual class.  For example in our code base there’s
    %% frequent mocking of the HttpRequest object and we have a MockReqeust object
    %% which is a subclass of HttpRequest so that these can still be mocked
    %% (luckily this actually pre-dated our static conversion work).

\begin{enumerate}
  \item
    \ipara{Fix type errors due to mock wrappers}
    When test code introduces a mock wrapper, it may inadvertantly change the
    return type of a function.
    For example, the wrapped version of a function that returns \code{None}
    will return a \code{MagicMock} object unless the programmer explicitly
    specifies \code{None} as the desired return value.
    %% Carl: This is an inherent and desired
    %% incompatibility; next half we plan to work on improving the Python mock
    %% framework to automatically create mocks of the correct types.

  \item
    \ipara{Change mocked function to expect positional arguments}
    \SP{} currently rewrites all function calls to use positional arguments.
    Mock-wrapped functions therefore need to use positional arguments instead of keywords.
    %% Carl: we plan to fix this incompatibility by falling back to the original call
    %% arguments when we detect the target function has been patched.

  \item
    \ipara{Change functions to accept positional arguments}
    Functions that expect only keyword arguments cannot yet be called from \SP{} contexts.
    %% Carl: We plan to support this next half.

  \item
    \ipara{Organize class and instance attributes}
    Whereas Python allows class attributes to serve as default values for instance attributes,
    \SP{} does not.
    Programmers have to decide where an attribute belongs so that \SP{} can optimize
    reads from instance attributes.
    %% Carl: (efficient via \code{LOAD\_FIELD})
    %% - related to github #37 ?

  \item
    \ipara{Move \code{@dataclass} and \code{Enum} classes}
    \SP{} does not support classes decorated with \code{@dataclass}
    and classes that are enums.
    For now, programmers have to move these classes to an untyped module.
    %% Carl: We have work in progress on supporting some Enum types, and plan to add a @dataclass intrinsic soon.

  \item
    \ipara{Remove unsupported Python features}
    Occurrences of the dynamic Python features listed in \cref{s:dynamic-python} must be rewritten or moved.
    %% According to the \SP{} team, these changes have not required any major rewrites.

\end{enumerate}


%% TODO section formatting looks good?
\subsubsection{Code Changes for Performance}

\begin{enumerate}
  \item
    \ipara{Use primitive types}
    Any Python integers and booleans in hot code paths are better as
    \SP{} primitive values~(\cref{s:c-types}).
    As noted above, primitives were required for \SP{} to match the performance of
    Cython.
    Twelve modules currently use primitives.
    %% - bg: focus on block, convert, no problem?

  \item
    \ipara{Use concrete types}
    Three modules currently use a concrete dictionary type
    (of the form $\sptchkdict{\sptype}{\sptype}$)
    and six modules use a checked list type.
    %% - bg: how occasional? worried about power of the "gradual soundness" claim

  \item
    \ipara{Convert \code{@classmethod} to \code{@staticmethod}}
    Static methods can get invoked directly as functions, bypassing the class vtable.
    Twenty-four modules use static methods, though many of these uses pre-date \SP{}.
    %% 2022-01-12 Carl:
    %% I don’t think it was a super common change, but there were some cases where we
    %% changed a @classmethod that didn’t actually use its cls argument to a
    %% @staticmethod. It looks like we have 24 static modules using a
    %% @staticmethod somewhere in the module, but I think in the majority of those
    %% there just happened to be some pre-existing staticmethods (they aren’t
    %% uncommon in our codebase); I think a minority were intentional
    %% optimizations on our part. And the pre-existing ones may or may not be
    %% meaningfully improving performance. So I’m not sure how valuable it is to
    %% report this metric.


\end{enumerate}

%% More Migration Notes

%% 2022-01-12 Carl:
%% We did have some cases where strict semantics caused a problem, but in the
%% majority of conversions it didn’t (or if it did initially, the fix was
%% trivial.) There was at least one case where I would have converted more code to
%% static but couldn’t easily do so because of strictness issues with a larger
%% framework reliant on metaclasses, and so I instead extracted the hottest code
%% paths into a new strict/static module and called them. I have a plan to go back
%% to this and improve the framework itself to be strict so more code can be
%% converted. I know of at least one other case where we did modify a framework
%% that relied on side-effecting decorators so that it could be used without the
%% side effects.


\subsubsection{Developer Experience}

For the most part, programmers have been happy adopting \SP{}.
The transition from Pyre to \SP{} has delivered performance benefits
that outweigh the cost of code changes.
Even the use of strict modules has been acceptable; only two modules
required non-trivial rewrites to avoid mutation.

One significant pushback dealt with multiple inheritance.
The \SP{} team proposed a rewrite from multiple inheritance to single inheritance,
but the code maintainers preferred to keep the design as-is.


\subsection{Microbenchmarks}
%% https://github.com/facebookincubator/cinder/tree/cinder/3.8/Tools/benchmarks
%% https://docs.google.com/spreadsheets/d/1IO25bL_8LwDqx3ciQTj9dMetsFnZFdiQIyjFvgYWIpI/edit?usp=sharing

\Cref{t:microbenchmark} compares \SP{} to Python on public microbenchmarks.
These microbenchmarks are admittedly small and quite different than typical application code,
but they provide an auditable and reproducible way to measure performance.
Each row presents two ratios.
The first compares a simply-typed version of the benchmark to untyped Python code.
The second compares a hand-refined benchmark to untyped Python.
The refinements are modest, mostly adding primitive types to hot loops;
they do not require siginificant expertise to reproduce.

All runtimes for this table came from a 64-bit CentOS Linux system using a build
of \SP{} and Cinder compiled with default settings
(commit \href{https://github.com/facebookincubator/cinder/commit/d0d071a9acf3e65700e7c6f8982c5087c700d116}{\code{d0d071a}}).
Each benchmark version ran 11 times total: once to warm up the JIT and 10 times to
compute an average runtime (using the \code{time} utility).
Every benchmark version invoked the JIT on the same functions---even the untyped versions.

\begin{table}[t]
  \caption{Microbenchmark performance ratios. NB: data for deltablue and nbody is pending.}
  \label{t:microbenchmark}
  \begin{tabular}{lrr}
    Name               & Typed / Python & Refined / Python \\\midrule
    \bmname{deltablue} &          TBD &            TBD \\
    \bmname{nbody}     &          TBD &            TBD \\
    \bmname{richards}  &         0.53 &           0.22 \\
    \bmname{fannkuch}  &         1.03 &           0.46
    %% fannkuch typedbasic2 = 0.90
  \end{tabular}
\end{table}

Almost all ratios are less than one, showing that \SP{} achieves a speedup over
Python despite the cost of enforcing soundness.
The one exception is the basic typed version of \bmname{fannkuch}, which sees a minor
slowdown.
This benchmark is primarily about number-crunching; and indeed, changing a few simple
types to primitive types without modifying the code leads to a minor speedup (ratio = $0.90$).


\section{Related Work}
\label{s:related}

Concrete types originated in Thorn~\cite{bloom,wnlov-popl-2010}
and StrongScript~\cite{rzv-ecoop-2015},
and play a central role in Nom~\cite{mt-oopsla-2017} and MonNom~\cite{mt-oopsla-2021}.
It was thanks to Nom that \SP{} acquired concrete types; the impressive performance results
in the original Nom paper inspired the \SP{} team to pursue an implementation.

In addition to concrete types, Thorn and StrongScript have optional like types.
The mix of like and concrete types is similar to \SP{}'s mix of concrete and shallow
types, though like types make no claims about soundness.

Many aspects of our Redex model for \SP{} are adapted from the Full Monty core calculus
for Python~\cite{pmmwplck-oopsla-2013}.
In particular, the Full Monty paper reminded us that booleans \emph{are} integers in Python;
\SP{} had overlooked this detail.\footnote{Bug report: \url{https://github.com/facebookincubator/cinder/issues/46}}
%% 2022-01-14 TODO check full monty with KC

Our production experience with \SP{} suggests that a method-based JIT compiler can
usually eliminate the costs of shallow types.
This finding complements prior positive experience with shallow types and JIT
technology; e.g., in Reticulated with the pypy tracing JIT~\cite{vsc-dls-2019}
and in Grace with the Graal partial-evaluation-based JIT~\cite{rmhn-ecoop-2019,grmhn-vmil-2019}.
Similarly, the Pycket team used a tracing JIT to reduce the costs of higher-order
checks~\cite{bbst-oopsla-2017}.
It remains to be seen whether a non-tracing JIT is effective for higher-order
casts.

\SP{} is one of many type systems for Python.
Other optional type checkers include Pyre, mypy, and PyType;
these systems do not ensure safe interactions with untyped Python.
Another sound type system is Reticulated,
which enforces structural types (rather than nominal) using its transient
semantics~\cite{vss-popl-2017,v-thesis-2019}.
Other \emph{optimizing} type systems for Python
include Reticulated and mypyc.
The latter compiles Python source to C extension modules; unlike \SP{},
it does not offer a pure-Python developer experience.

Although sound gradual type systems are rare in industry, there are at
least three others besides \SP{}.
Dart 2 is a nominally-typed language with a dynamic type that is similar
to the top object type but allows implicit downcasts to every other type~\cite{dart-types}.
C\# includes a dynamic type that defers type checking until runtime~\cite{bmt-ecoop-2010}.
JS++ is a sound type system for JavaScript that allows untyped values
using a catch-all \code{external} type~\cite{jspp}.
%% Programmers can manually cast external values to a more precise type.
%% The non-immediate casts make copies (how does that work for functions?!)
%% also, how does JS++ protect arrays sent to JS?

Gradual soundness in \SP{} bears a strong resemblance to \emph{progressive types} vision
of a type system that comes in strict and lax forms~\cite{pqk-onward-2012}.
Primitive types are progressive types for base values.
Concrete types are essentially a progressive form of shallow types.


%% \section{Future Work}
%% \label{s:future}
%% 
%% %% Immediate future: fix adoption friction points
%% %% - mocks need manual return_value ... "next half we plan to work on improving the Python mock framework to automatically create mocks of the correct types."
%% %% - mock calls have to rewrite to expect positional args, not keywords "plan to avoid rewrite if fn is patched"
%% %% - functions have to expect positionals (can't do keyword only)
%% %% - @dataclass enum.Enum
%% %%
%% %% significant selection bias toward low-hanging fruit
%% %% model: metaclasses
%% %% engineering: JIT profiling, instead of hand-requested JIT list
%% 
%% Adapt SP ideas to a new setting, test performance takeaways.
%% 
%% Improve SP with generic types, structural types (lambda), \ldots.
%% 
%% Use confined GT to relax ChkDict ... let programmers decide whether
%% the type should reject or convert untyped data.
%% Maybe a ChkDict function could compile to an "overloaded" version with
%% fast and slow paths for ChkDict vs normal dict.
%% 
%% Build an automatic migration tool for Checked data.
%% 
%% Build a static analysis that hoists transient annotations to an early, shared point.
%% Take care to give quality error messages.
%% 
%% Optimize Python integer operations (in addition to the c types).
%% Hard because syntax like \code{a + b} may be the result of either \code{a.\_\_add\_\_(b)}
%% or \code{b.\_\_radd\_\_(a)} depending on runtime types and behavior.


\section{Lessons}
\label{s:conclusion}

%% 2021-12-30 Whence Nominal GT?
%%
%% KC: I think in general adding gradual typing to Java/C# (an also Python) is boring:
%% - MonNom allows you to cast between an arbitrary type and dyn.
%% - dyn is effectively Object
%% - Upcasts, casts from an arbitrary type to Object, are already in the language
%% - Downcasts, casts from Object to an arbitrary type is also possible, but must be explicit in the fully static language
%% So MonNom effectively gives programmers another way to name Object, with which downcasts can be automatically inserted by the compiler.
%% I think this sentence covers all the interesting stuff about MonNom.
%%
%% SK: This matches my intuition that gradual nominal is just not very
%% interesting. KC puts this on a technical footing with his very astute comment,
%% which to me can be summarized as "every nominal language that has Object is
%% already gradual" [leaving aside the boring non-Object base type distinction].
%%     So the entire remaining game is one of making the programming interface
%% as painless as possible. Some of that is just a trivial matter of
%% syntactic defaults; some of it is making the type-checker more forgiving
%% and replacing static checks with dynamic checks. There doesn't seem to
%% be much else left.

\SP{} is an ambitious undertaking.
Its developers are maintaining a fork of the Python 3.8 runtime,
a type checker,
an optimizing ahead-of-time compiler,
and a method-based JIT compiler.
The team has converted hundreds of untyped modules to \SP{}
and plans to convert thousands more in the future.

And yet, \SP{} is carefully restricted to set attainable goals
for its implementors and for adopters:
\begin{itemize}
  \item
    The syntax of sound static types is relatively small compared
    to Pyre~\cite{pyre} and other types-for-Python proposals~\cite{mypy,pytype}.
    Higher-order types are absent.
    The focus is instead on first-order class types, base types, and standard data structures.
  \item
    The type checker operates at a module-level granularity rather
    than at the level of statements or expressions.
  \item
    Gradual class hierarchies are permitted, but restricted to single inheritance.
    Furthermore, static-to-static method overrides cannot reduce the precision of types---a restriction
    that enables optimizations but breaks the static gradual guarantee.
  \item
    Shallow types such as $\sptrawpydict$ accommodate Python code but offer coarse
    soundness guarantees.
    These types have been the top priority for \SP{}.
    Concrete types support full soundness, but impose nonlocal maintenace costs.
    \SP{} supports few concrete types at the moment and plans to add more.
  \item
    Progressive primitive types are available to help developers maximize performance.
    These types are intentionally incompatible with the dynamic type to help programmers
    avoid casts at run-time.
\end{itemize}
%
Many of these restrictions go against the grain of the mainstream
research community, but they have been effective in practice.
The current \CPUchange{} increase in CPU usage is a huge improvement
at the scale of the Instagram web server.

In conclusion, we conjecture that the \SP{} approach to gradual typing
is a viable way to incrementally add types to a production codebase.
Determining whether this conjecture holds more broadly is a critical
question that calls for research on two fronts.
First, \SP{} must be applied to additional projects in a module-at-a-time manner.
A exhaustive performance evaluation~\cite{gtnffvf-jfp-2019} of a few small projects would be
especially useful.
Second, the \SP{} approach should be adapted to other languages.
An optionally-typed language such as TypeScript would be an ideal starting
point for such an experiment.


%\acks{
%  Thanks to
%  Guido van Rossum for stimulating tweets.
%  This work was partly supported by the US National Science Foundation.
%  This research was also developed with funding from the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL).
%  The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S.~Government.
%  Greenman received support from NSF grant 2030859 to the CRA for the \href{https://cifellows2020.org}{CIFellows} project.
%}

{\sloppy
\printbibliography
}

\appendix

\section{GitHub Issues}
\label{a:github-issues}

The 25 GitHub issues that arose from our work may be found at the following three links:

\begin{itemize}
  \item \shorturl{https://}{github.com/facebookincubator/cinder/issues/created\_by/LuKC1024} (N=20)
  \item \shorturl{https://}{github.com/facebookincubator/cinder/issues/created\_by/bennn} (N=4)
  \item \shorturl{https://}{github.com/facebookincubator/cinder/issues/64} (N=1)
  %% extra, can't remember if we inspired Dino or not: https://github.com/facebookincubator/cinder/issues/32
\end{itemize}


\section{On Migrations from Pyre to \SP{}}

Although the Instagram web server has extensive Pyre annotations,
these annotations are not always enough to satisfy \SP{}.
In fact, code may have latent bugs that Pyre did not catch;
we list common reasons for such bugs below:

\begin{itemize}
  \item
    Pyre misses some bugs because it does not monitor run-time interactions
    with untyped code.

  \item
    Similarly, some uses of the Pyre dynamic type (\code{Any}) end up
    raising errors when \SP{} monitors their interactions with precisely-typed code.

  \item
    Occurrences of the special comment \lstinline$# pyre-fixme$ disable Pyre checks.

  \item
    Some annotations intentionally lie to reduce the work of maintaining types.
    For example:

    \begin{itemize}
      \item
        The standard \code{typeshed} repo of Python type annotations declares
        that a weak reference has the dynamic type~\cite{typeshed}.
        This declaration is easy to use because it does not force programmers
        to handle the case where their weakly-held object has been collected,
        but it is also a potential source of bugs.
      \item
        Mutable class attributes are covariant in Pyre and other
        Python type checkers, including mypy~\cite{mypy}.
      \item
        The meta-type \code{Type} is unsoundly covariant as well in Pyre
        and others.
      \item
        Argument splatting, i.e. applying a function that expects positional
        arguments to a list (\code{f(*lst)}), is not statically checked
        either.
    \end{itemize}

\end{itemize}

None of these issues are problems with Pyre.
Quite naturally, it cannot find bugs in code that it does not analyze!
Our point is simply that optional type systems can miss a variety of issues.


\section{Fine-Grained Benchmark Data}

\newcommand{\colname}[1]{\textbf{#1}}

The tables in this section present fine-grained data for the microbenchmark programs.
Each benchmark has several versions of its code that accomplish the same work:
the original untyped version (\colname{Orig}) and a typed version (\colname{T-Max}) converted for maximum
performance under Static Python and the JIT.
Some benchmarks have a basic typed version (\colname{T-Min}) that adds only
type annotations and necessary casts to the original code,
without using any more advanced Static Python
features such as primitive types or otherwise optimizing the code for Static
Python.
Fannkuch has a second basic version (\colname{T-Min2}) that uses just a few primitive integers
where it can be done without significant changes to the code.

The other axes of our test matrix are \colname{SP} (whether the Static Python compiler is
used), \colname{JIT} (whether the Cinder JIT is enabled), and \colname{SF} (whether the JIT
shadow-frame mode is enabled, which reduces Python frame allocation costs.) The
matrix is not complete, since using the Static Python compiler on untyped code
has no noticeable effect, and shadow-frame mode is only relevant under the JIT.

Benchmarks are run on a 64-bit CentOS Linux system, using a build of Cinder
compiled with default configure settings. Overall process user time is measured
via the \code{time} utility. Each benchmark/configuration is run 10 times (after an
initial warmup run to ensure there is an up-to-date bytecode cache file and
compilation time will not be included), and all individual data points are
recorded. All data points are in seconds.

JIT runs use a JIT list that includes only the benchmark code itself, to
minimize overhead of compiling unrelated standard library code not used in the
benchmark.

Benchmarks run on the following commit:

\smallskip
{\centering\footnotesize\url{https://github.com/facebookincubator/cinder/commit/d0d071a9acf3e65700e7c6f8982c5087c700d116}}

Fannkuch in particular is very numeric-heavy, so using unboxed primitive
integers in the typed version can be a big win. For this to work maximally
efficiently, we also need to avoid operations that don't yet support primitives
and thus would require expensive boxing. In typed-and-optimized Fannkuch (\colname{T-Max}), these changes move
a lot of the work out of heavily-optimized C builtin methods (for list
slice/insert/pop) and into simple Python code doing the equivalent operations
manually with simple iteration and indexing. In the short run this is a massive
pessimization for non-static Python (or even SP without the JIT, since
currently we always use boxed integers in the interpreter loop.) In the long
run it suggests that Static Python + JIT could make it feasible to implement
many more of these core datastructure operations in pure Python rather than in
C.

Because of this subtlety, we include benchmark results for both typed and
untyped versions of each benchmark. In the short term, perhaps the most
relevant comparison is the performance of Static Python on the typed benchmark
vs the performance of nonstatic Python on the untyped benchmark; this gives a
fair picture of expected perf gains converting code to Static Python with some
willingness to optimize.

We also observe significant untapped opportunity to improve Static Python's
performance; for example, $20\%$ of Typed Fannkuch SP+JIT time is spent on
bounds-checking array accesses; most of this runtime bounds-checking cost could
be eliminated if the Static Python compiler tracks known array sizes and
integer values more thoroughly. And it would also be possible to support list
slicing, list pop, and list insert with primitive arguments, thus avoiding the
need to rewrite these operations in Python for maximum efficiency.

\colname{T-Min} Fannkuch without the JIT is slow because of a known issue where we
don't cache function lookups for \code{INVOKE\_FUNCTION} in the interpreter loop,
making the calls to \code{list.insert} and \code{list.pop} slower; this is fixable.

\begin{landscape}

\begin{table}[tph]
  \caption{Richards microbenchmark data}
  \label{t:mb:richards}
  \footnotesize

  \begin{tabular}{rrrrrrrrrrrrrrr}
  \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{Orig} & \colname{Orig} & \colname{Orig} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & (\colname{SP} \colname{JIT}) & (\colname{SP}) & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () & (\colname{SP} \colname{JIT} \colname{SF}) & (\colname{SP} \colname{JIT}) & (\colname{SP}) & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () \\\hline
  $0.57$ & $1.29$ & $7.86$ & $8.36$ & $10.24$ & $16$ & $1.41$ & $2.68$ & $7.67$ & $5.58$ & $7.97$ & $13.32$ & $2.6$ & $3.88$ & $10.17$ \\
  $0.59$ & $1.32$ & $7.92$ & $8.84$ & $9.97$ & $15.73$ & $1.38$ & $2.6$ & $7.9$ & $5.92$ & $7.25$ & $13.59$ & $2.6$ & $4.01$ & $10.18$ \\
  $0.58$ & $1.33$ & $7.89$ & $8.9$ & $10.57$ & $16.2$ & $1.39$ & $2.64$ & $7.74$ & $5.54$ & $7.64$ & $13.83$ & $2.61$ & $4.17$ & $10.73$ \\
  $0.58$ & $1.33$ & $7.92$ & $8.53$ & $10.71$ & $16.71$ & $1.38$ & $2.65$ & $7.8$ & $6.06$ & $7.24$ & $13.95$ & $2.9$ & $3.92$ & $9.96$ \\
  $0.56$ & $1.33$ & $7.83$ & $9.15$ & $9.89$ & $16.62$ & $1.37$ & $2.62$ & $7.68$ & $5.52$ & $7.2$ & $13.5$ & $2.63$ & $3.79$ & $10.04$ \\
  $0.56$ & $1.33$ & $7.97$ & $8.25$ & $10.44$ & $15.65$ & $1.39$ & $2.58$ & $7.8$ & $5.63$ & $7.27$ & $13.52$ & $2.64$ & $3.95$ & $9.99$ \\
  $0.55$ & $1.32$ & $8.18$ & $8.78$ & $10.07$ & $16.22$ & $1.36$ & $2.65$ & $7.79$ & $5.74$ & $7.17$ & $13.34$ & $2.62$ & $3.9$ & $10.16$ \\
  $0.55$ & $1.31$ & $7.85$ & $8.67$ & $10.07$ & $15.73$ & $1.43$ & $2.66$ & $7.82$ & $5.56$ & $7.54$ & $13.68$ & $2.6$ & $3.84$ & $9.69$ \\
  $0.56$ & $1.31$ & $7.96$ & $8.52$ & $10.14$ & $15.82$ & $1.53$ & $2.63$ & $7.9$ & $5.59$ & $6.89$ & $13.79$ & $2.6$ & $4.04$ & $9.82$ \\
  $0.57$ & $1.32$ & $8$ & $8.35$ & $10.57$ & $16.66$ & $1.37$ & $2.71$ & $7.95$ & $5.74$ & $6.91$ & $13.5$ & $2.62$ & $3.85$ & $9.85$ \\
\end{tabular}

\end{table}
\end{landscape}

\begin{landscape}
\begin{table}[tph]
  \caption{Fannkuch microbenchmark data}
  \label{t:mb:fannkuch}
  \footnotesize

  \begin{tabular}{rrrrrrrrrrrrrrr}
  \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Max} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min} & \colname{T-Min2} & \colname{T-Min2} & \colname{T-Min2} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & (\colname{SP} \colname{JIT}) & (\colname{SP}) & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () & (\colname{SP} \colname{JIT} \colname{SF}) & (\colname{SP} \colname{JIT}) & (\colname{SP}) & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () & (\colname{SP} \colname{JIT} \colname{SF}) & (\colname{SP} \colname{JIT}) & (\colname{SP}) \\\hline
  $1.27$ & $1.39$ & $34.69$ & $40.74$ & $41$ & $48.23$ & $2.77$ & $2.83$ & $6.18$ & $2.89$ & $2.86$ & $4.07$ & $2.48$ & $2.52$ & $7.28$ \\
  $1.32$ & $1.25$ & $34.35$ & $40.23$ & $40.94$ & $49.03$ & $2.85$ & $2.8$ & $6.12$ & $2.94$ & $2.9$ & $4.06$ & $2.52$ & $2.48$ & $7.28$ \\
  $1.28$ & $1.26$ & $34.67$ & $40.74$ & $40.65$ & $49.42$ & $2.79$ & $2.77$ & $6.38$ & $2.87$ & $2.86$ & $4.1$ & $2.47$ & $2.53$ & $7.24$ \\
  $1.23$ & $1.31$ & $35.71$ & $40.94$ & $39.7$ & $49.35$ & $2.87$ & $2.81$ & $6.23$ & $2.87$ & $2.85$ & $4.29$ & $2.48$ & $2.57$ & $7.35$ \\
  $1.28$ & $1.38$ & $34.85$ & $39.59$ & $40.46$ & $49.18$ & $2.85$ & $2.84$ & $6.17$ & $2.92$ & $2.81$ & $4.14$ & $2.5$ & $2.56$ & $7.34$ \\
  $1.26$ & $1.34$ & $33.96$ & $40.45$ & $39.99$ & $47.79$ & $2.87$ & $2.8$ & $6.21$ & $2.94$ & $2.8$ & $4.06$ & $2.43$ & $2.47$ & $7.17$ \\
  $1.26$ & $1.23$ & $34.65$ & $40.78$ & $40.97$ & $49.7$ & $2.92$ & $2.76$ & $6.04$ & $3.11$ & $3.05$ & $4.08$ & $2.47$ & $2.69$ & $7.18$ \\
  $1.27$ & $1.35$ & $33.83$ & $40.96$ & $41.78$ & $47.92$ & $2.78$ & $2.76$ & $6.13$ & $3.1$ & $2.86$ & $4.19$ & $2.47$ & $2.45$ & $7.14$ \\
  $1.23$ & $1.4$ & $36.23$ & $40.49$ & $40.29$ & $48.68$ & $2.84$ & $2.76$ & $6.13$ & $2.87$ & $2.96$ & $4.31$ & $2.43$ & $2.55$ & $7.23$ \\
  $1.23$ & $1.27$ & $36.05$ & $40.72$ & $40.11$ & $48.29$ & $2.92$ & $2.79$ & $6.17$ & $2.91$ & $2.96$ & $4.1$ & $2.52$ & $2.49$ & $7.2$ \\
\end{tabular}

\begin{tabular}{rrrrrr}
  \colname{T-Min2} & \colname{T-Min2} & \colname{T-Min2} & \colname{Orig} & \colname{Orig} & \colname{Orig} \\
  (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () & (\colname{JIT} \colname{SF}) & (\colname{JIT}) & () \\\hline
  $3.16$ & $3.08$ & $4.59$ & $2.81$ & $2.94$ & $4.02$ \\
  $3.26$ & $3.08$ & $4.51$ & $2.66$ & $2.85$ & $4.22$ \\
  $3.11$ & $3.18$ & $4.59$ & $2.69$ & $2.78$ & $4.01$ \\
  $3.18$ & $3.14$ & $4.73$ & $2.75$ & $2.8$ & $4.01$ \\
  $3.14$ & $3.12$ & $4.63$ & $2.75$ & $2.92$ & $4.07$ \\
  $3.23$ & $3.09$ & $4.53$ & $2.78$ & $2.83$ & $4.36$ \\
  $3.41$ & $3.21$ & $4.48$ & $2.84$ & $2.81$ & $4.19$ \\
  $3.43$ & $3.14$ & $4.53$ & $2.7$ & $2.86$ & $4.25$ \\
  $3.08$ & $3.24$ & $4.53$ & $2.76$ & $2.78$ & $4.08$ \\
  $3.16$ & $3.18$ & $4.45$ & $2.89$ & $2.76$ & $4.16$ \\
\end{tabular}
\end{table}

\end{landscape}

\begin{table}[tph]
  \caption{Exact commands to invoke each benchmark}
  \label{t:mb:commands}
  \tiny

  \begin{tabular}{ll}
  \colname{Benchmark} & \colname{Command} \\\hline
  Richards \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & \texttt{ -X jit-shadow-frame -X install-strict-loader Tools/benchmarks/richards\_static.py 100} \\
  Richards \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{SP} \colname{JIT}) & \texttt{ -X install-strict-loader Tools/benchmarks/richards\_static.py 100} \\
  Richards \colname{T-Max} & \texttt{time ./python -X install-strict-loader Tools/benchmarks/richards\_static.py 100} \\
  (\colname{SP}) &  \\
  Richards \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{JIT} \colname{SF}) & \texttt{ -X jit-shadow-frame Tools/benchmarks/richards\_static.py 100} \\
  Richards \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{JIT}) & \texttt{ Tools/benchmarks/richards\_static.py 100} \\
  Richards \colname{T-Max} & \texttt{time ./python Tools/benchmarks/richards\_static.py 100} \\
  () &  \\
  Richards \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & \texttt{dcards -X jit-shadow-frame -X install-strict-loader Tools/benchmarks/richards\_static\_basic.py 100} \\
  Richards \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{SP} \colname{JIT}) & \texttt{dcards -X install-strict-loader Tools/benchmarks/richards\_static\_basic.py 100} \\
  Richards \colname{T-Min} & \texttt{time ./python -X install-strict-loader Tools/benchmarks/richards\_static\_basic.py 100} \\
  (\colname{SP}) &  \\
  Richards \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{JIT} \colname{SF}) & \texttt{dcards -X jit-shadow-frame Tools/benchmarks/richards\_static\_basic.py 100} \\
  Richards \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_richards\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{JIT}) & \texttt{dcards Tools/benchmarks/richards\_static\_basic.py 100} \\
  Richards \colname{T-Min} & \texttt{time ./python Tools/benchmarks/richards\_static\_basic.py 100} \\
  () &  \\
  Richards \colname{Orig} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_main.txt -X jit-enable-jit-list-wildcards -X jit-sha} \\
  (\colname{JIT} \colname{SF}) & \texttt{dow-frame Tools/benchmarks/richards.py 100} \\
  Richards \colname{Orig} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_main.txt -X jit-enable-jit-list-wildcards Tools/benc} \\
  (\colname{JIT}) & \texttt{hmarks/richards.py 100} \\
  Richards \colname{Orig} & \texttt{time ./python Tools/benchmarks/richards.py 100} \\
  () &  \\
  Fannkuch \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & \texttt{ -X jit-shadow-frame -X install-strict-loader Tools/benchmarks/fannkuch\_static.py 5} \\
  Fannkuch \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{SP} \colname{JIT}) & \texttt{ -X install-strict-loader Tools/benchmarks/fannkuch\_static.py 5} \\
  Fannkuch \colname{T-Max} & \texttt{time ./python -X install-strict-loader Tools/benchmarks/fannkuch\_static.py 5} \\
  (\colname{SP}) &  \\
  Fannkuch \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{JIT} \colname{SF}) & \texttt{ -X jit-shadow-frame Tools/benchmarks/fannkuch\_static.py 5} \\
  Fannkuch \colname{T-Max} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static.txt -X jit-enable-jit-list-wildcards} \\
  (\colname{JIT}) & \texttt{ Tools/benchmarks/fannkuch\_static.py 5} \\
  Fannkuch \colname{T-Max} & \texttt{time ./python Tools/benchmarks/fannkuch\_static.py 5} \\
  () &  \\
  Fannkuch \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & \texttt{dcards -X jit-shadow-frame -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  Fannkuch \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{SP} \colname{JIT}) & \texttt{dcards -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  Fannkuch \colname{T-Min} & \texttt{time ./python -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  (\colname{SP}) &  \\
  Fannkuch \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{JIT} \colname{SF}) & \texttt{dcards -X jit-shadow-frame Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  Fannkuch \colname{T-Min} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic.txt -X jit-enable-jit-list-wil} \\
  (\colname{JIT}) & \texttt{dcards Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  Fannkuch \colname{T-Min} & \texttt{time ./python Tools/benchmarks/fannkuch\_static\_basic.py 5} \\
  () &  \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic2.txt -X jit-enable-jit-list-wi} \\
  (\colname{SP} \colname{JIT} \colname{SF}) & \texttt{ldcards -X jit-shadow-frame -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic2.txt -X jit-enable-jit-list-wi} \\
  (\colname{SP} \colname{JIT}) & \texttt{ldcards -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python -X install-strict-loader Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  (\colname{SP}) &  \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic2.txt -X jit-enable-jit-list-wi} \\
  (\colname{JIT} \colname{SF}) & \texttt{ldcards -X jit-shadow-frame Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_fannkuch\_static\_basic2.txt -X jit-enable-jit-list-wi} \\
  (\colname{JIT}) & \texttt{ldcards Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  Fannkuch \colname{T-Min2} & \texttt{time ./python Tools/benchmarks/fannkuch\_static\_basic2.py 5} \\
  () &  \\
  Fannkuch \colname{Orig} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_main.txt -X jit-enable-jit-list-wildcards -X jit-sha} \\
  (\colname{JIT} \colname{SF}) & \texttt{dow-frame Tools/benchmarks/fannkuch.py 5} \\
  Fannkuch \colname{Orig} & \texttt{time ./python -X jit -X jit-list-file=Tools/benchmarks/jitlist\_main.txt -X jit-enable-jit-list-wildcards Tools/benc} \\
  (\colname{JIT}) & \texttt{hmarks/fannkuch.py 5} \\
  Fannkuch \colname{Orig} & \texttt{time ./python Tools/benchmarks/fannkuch.py 5} \\
  () &  \\
\end{tabular}

\end{table}



\end{document}
